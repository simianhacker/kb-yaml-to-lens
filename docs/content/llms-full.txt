# Dashboard Compiler - Complete Documentation

> This file contains all documentation for the Dashboard Compiler project.

---



---
# Source: index.md
---

# YAML ➤ Lens Dashboard Compiler

Convert human-friendly YAML dashboard definitions into Kibana NDJSON format.

![The Chameleon mascot](./images/project-banner-smaller.png)

This tool simplifies the process of creating and managing Kibana dashboards by
allowing you to define them in a clean, maintainable YAML format instead of
hand-crafting complex JSON.

## Getting Started

### VS Code Extension (Recommended)

**Best for interactive development** - Live preview, visual editing, built-in snippets

**No Python installation required!** The extension includes a bundled LSP server binary.

**Installation:**

1. **Install the extension:**
   - **OpenVSX Registry** (Cursor, VS Code forks): Search "Kibana Dashboard Compiler"
   - **Manual**: Download `.vsix` from [releases](https://github.com/strawgate/kb-yaml-to-lens/releases)

2. **Create your first dashboard:**

   Create a new file called `my-dashboard.yaml` and add the following content:

   ```yaml
   dashboards:
   - name: My First Dashboard
     description: A simple dashboard with markdown
     panels:
       - title: Hello Panel
         markdown:
           content: |
             # Hello, Kibana!

             This is my first markdown panel.
         size: {w: 24, h: 15}
   ```

   Or use snippets: type `dashboard` and press Tab to insert a template.

3. **Preview your dashboard:**
   - Save the file (Ctrl+S) to auto-compile
   - Open Command Palette (Ctrl+Shift+P / Cmd+Shift+P)
   - Run **"YAML Dashboard: Preview Dashboard"**

4. **Upload to Kibana:**
   - Configure Kibana URL in VS Code settings
   - Run **"YAML Dashboard: Open in Kibana"**

**Full guide:** [VS Code Extension Documentation](vscode-extension.md)

---

### CLI (For Automation & Scripting)

**Best for:** CI/CD pipelines, batch processing, programmatic usage

**Requirements:** Python 3.12+

**Installation** using [uv](https://github.com/astral-sh/uv):

```bash
cd compiler
uv sync
```

**Your First Dashboard:**

1. Create `inputs/my-dashboard.yaml`:

   ```yaml
   dashboards:
   - name: My First Dashboard
     description: A simple dashboard
     panels:
       - title: Welcome
         size: {w: 24, h: 15}
         markdown:
           content: |
             # Welcome to Kibana!
   ```

2. Compile:

   ```bash
   cd compiler
   uv run kb-dashboard compile
   ```

3. Upload to Kibana:

   ```bash
   uv run kb-dashboard compile --upload --kibana-url http://localhost:5601
   ```

**Full guide:** [CLI Documentation](CLI.md)

---

## Features

- **YAML-based Definition** – Define dashboards, panels, filters, and queries in simple, readable YAML.
- **Kibana Integration** – Compile to NDJSON format compatible with Kibana 8+.
- **Rich Panel Support** – Support for Lens (metric, pie, XY charts), Markdown, Links, Image, and Search panels.
- **Color Palettes** – Choose from color-blind safe, brand, and other built-in color palettes.
- **Interactive Controls** – Add options lists, range sliders, and time sliders with chaining support.
- **Flexible Filtering** – Use a comprehensive filter DSL (exists, phrase, range) or raw KQL/Lucene/ESQL queries.
- **Direct Upload** – Compile and upload to Kibana in one step, with support for authentication and API keys.
- **Screenshot Export** – Generate high-quality PNG screenshots of your dashboards programmatically.

## More Examples

### Lens Metric Panel

Here's a dashboard with a Lens metric panel displaying a count:

```yaml
dashboards:
- name: Metric Dashboard
  description: A dashboard with a single metric panel
  panels:
    - title: Document Count
      type: lens
      size: {w: 24, h: 15}
      data_view: your-index-pattern-*
      chart:
        type: metric
        metrics:
          - type: count
            label: Total Documents
```

### Programmatic Alternative

While this guide focuses on YAML, you can also create dashboards entirely in Python code. This approach offers:

- Dynamic dashboard generation based on runtime data
- Type safety with Pydantic models
- Reusable dashboard templates and components
- Integration with existing Python workflows

See the [Programmatic Usage Guide](programmatic-usage.md) for examples and patterns.

## Next Steps

### Enhance Your Workflow

- **[VS Code Extension Features](vscode-extension.md)** - Visual grid editor, code snippets, keyboard shortcuts
- **[CLI Advanced Usage](CLI.md)** - Environment variables, API keys, CI/CD integration
- **[Dashboard Decompiling Guide](dashboard-decompiling-guide.md)** - Convert existing Kibana JSON dashboards to YAML
- **[Complete Examples](examples/index.md)** - Production-ready dashboard templates

### User Guide

Reference documentation for YAML dashboard syntax:

- **[Dashboard Configuration](dashboard/dashboard.md)** - Dashboard-level settings and options.
- **[Panel Types](panels/base.md)** - Available panel types (Markdown, Charts, Images, Links, etc.).
- **[Dashboard Controls](controls/config.md)** - Interactive filtering controls.
- **[Filters & Queries](filters/config.md)** - Data filtering and query configuration.

### Developer Guide

Advanced documentation for contributors and programmatic usage:

- **[Architecture Overview](architecture.md)** - Technical design and data flow.
- **[Programmatic Usage](programmatic-usage.md)** - Using the Python API directly to generate dashboards.
- **[API Reference](api/index.md)** - Auto-generated Python API documentation.
- **[Contributing Guide](https://github.com/strawgate/kb-yaml-to-lens/blob/main/CONTRIBUTING.md)** - How to contribute and add new capabilities.
- **[Kibana Architecture Reference](kibana-architecture.md)** - Understanding Kibana's internal structure.

## How It Works

```mermaid
graph TB
    YAML[YAML Definition]
    KIBANA[Kibana]

    subgraph "Interactive Development"
        EXT[VS Code Extension]
        EXT --> PREVIEW[Live Preview]
    end

    subgraph "Automation/CI"
        CLI[CLI Compiler]
        CLI --> NDJSON[NDJSON Files]
    end

    YAML --> EXT
    YAML --> CLI
    EXT --> KIBANA
    NDJSON --> KIBANA
```

## License

MIT

### Third-Party Content

Some example dashboards in `docs/content/examples/` are derived from the [Elastic integrations repository](https://github.com/elastic/integrations) and are licensed under the [Elastic License 2.0](https://github.com/strawgate/kb-yaml-to-lens/blob/main/licenses/ELASTIC-LICENSE-2.0.txt). Specifically:

- `docs/content/examples/system_otel/` - System monitoring dashboards for OpenTelemetry
- `docs/content/examples/docker_otel/` - Docker container monitoring dashboards for OpenTelemetry

See [licenses/README.md](https://github.com/strawgate/kb-yaml-to-lens/blob/main/licenses/README.md) for the complete list of affected files.

## Support

For issues and feature requests, please refer to the repository's issue tracker.


---
# Source: CLI.md
---

# Dashboard Compiler CLI

The `kb-dashboard` CLI tool allows you to compile YAML dashboard configurations to Kibana's NDJSON format and optionally upload them directly to Kibana.

## Prerequisites

- **Python 3.12+** - Required for CLI usage
- **[uv](https://github.com/astral-sh/uv)** (recommended) or pip for dependency management

**Note:** The VS Code Extension does not require Python - it includes a bundled binary. See [VS Code Extension Documentation](vscode-extension.md) for zero-configuration setup.

## When to Use the CLI

**Use the CLI when:**

- ✅ Building CI/CD pipelines for dashboard deployment
- ✅ Batch processing multiple dashboards
- ✅ Scripting dashboard generation (e.g., templates, dynamic data)
- ✅ Integrating with other automation tools
- ✅ Running in headless/server environments without GUI
- ✅ Using Docker containers or serverless functions

**Use the VS Code Extension when:**

- ✅ Developing dashboards interactively
- ✅ Learning the YAML schema
- ✅ Making frequent visual adjustments
- ✅ Needing live preview and validation

**See:** [VS Code Extension Documentation](vscode-extension.md) for interactive development workflow.

---

## Installation

After installing the project dependencies, the CLI will be available:

```bash
uv sync
```

## Basic Usage

### Compile Dashboards

Compile YAML dashboards to NDJSON format:

```bash
kb-dashboard compile
```

This will:

- Find all YAML files in `inputs/` (by default)
- Compile them to Kibana JSON format
- Output NDJSON files to `output/` directory
- Create individual NDJSON files per scenario
- Create a combined `compiled_dashboards.ndjson` file

### Compile a Single File

Compile a specific YAML file without scanning a directory:

```bash
kb-dashboard compile --input-file ./dashboards/example.yaml
```

When `--input-file` is provided, `--input-dir` is ignored.

### Export Individual JSON Files

For workflows that require individual JSON files per dashboard (e.g., Fleet integration):

```bash
kb-dashboard compile --format json --output-dir ./output
```

This will:

- Create one pretty-printed JSON file per dashboard
- Name files based on the dashboard title (sanitized for filesystem safety)

### CI Sync Detection

Use the `--exit-non-zero-on-change` flag to detect when YAML and JSON files are out of sync in CI pipelines:

```bash
kb-dashboard compile --format json --output-dir ./dashboards --exit-non-zero-on-change
if [ $? -ne 0 ]; then
    echo "Dashboard JSON files are out of sync with YAML sources"
    exit 1
fi
```

When this flag is enabled, the exit code equals the number of files that changed (capped at 125). By default, the command exits with code 0 on success regardless of whether files changed.

### Compile and Upload to Kibana

Compile dashboards and upload them directly to Kibana:

```bash
kb-dashboard compile --upload
```

This will compile the dashboards and upload them to a local Kibana instance.

### Screenshot Dashboards

Generate a PNG screenshot of a dashboard:

```bash
kb-dashboard screenshot --dashboard-id <id> --output <file.png>
```

This will use Kibana's Reporting API to take a screenshot.

### Export Dashboard for Issue

Export a dashboard from Kibana and create a pre-filled GitHub issue:

```bash
kb-dashboard export-for-issue --dashboard-id <id>
```

This will export the dashboard and open your browser with a pre-filled GitHub issue containing the dashboard JSON.

### Disassemble Dashboards

Break down a Kibana dashboard JSON into components for easier LLM-based conversion:

```bash
kb-dashboard disassemble dashboard.ndjson -o output_dir
```

This will extract the dashboard into separate files:

- `metadata.json` - Dashboard metadata (id, title, description, version)
- `options.json` - Dashboard display options
- `controls.json` - Control group configuration
- `filters.json` - Dashboard-level filters
- `references.json` - Data view references
- `panels/` - Individual panel JSON files

For a comprehensive guide on using this tool to convert dashboards from JSON to YAML, see the [Dashboard Decompiling Guide](dashboard-decompiling-guide.md).

## Configuration

### Environment Variables

The CLI supports configuration via environment variables:

```bash
export KIBANA_URL=http://localhost:5601
export KIBANA_USERNAME=elastic
export KIBANA_PASSWORD=changeme
export KIBANA_SPACE_ID=my-space  # Optional: target a specific Kibana space
# OR use API key instead
export KIBANA_API_KEY=your-api-key-here
```

Then simply run:

```bash
kb-dashboard compile --upload
```

### Command-Line Options

All options can also be specified on the command line:

```bash
kb-dashboard compile \
  --upload \
  --kibana-url http://localhost:5601 \
  --kibana-username elastic \
  --kibana-password changeme
```

To upload to a specific Kibana space:

```bash
kb-dashboard compile --upload --kibana-space-id production
```

Or with environment variables:

```bash
export KIBANA_SPACE_ID=staging
kb-dashboard compile --upload
```

## Command Reference

The following commands are available in the `kb-dashboard` CLI. For detailed information about each command and its options, see the auto-generated reference below.

::: mkdocs-click
    :module: dashboard_compiler.cli
    :command: cli
    :prog_name: kb-dashboard
    :depth: 2
    :style: table

## Makefile Shortcuts

The project includes convenient Makefile targets (run from `compiler/` directory):

```bash
# Compile only
cd compiler && make compile

# Compile and upload (uses environment variables for Kibana config)
cd compiler && make upload
```

Or use the CLI directly from anywhere with uv:

```bash
cd compiler && uv run kb-dashboard compile
cd compiler && uv run kb-dashboard compile --upload
```

## Authentication

The CLI supports two authentication methods:

### Basic Authentication

Use username and password:

```bash
kb-dashboard compile \
  --upload \
  --kibana-username elastic \
  --kibana-password changeme
```

Or via environment variables:

```bash
export KIBANA_USERNAME=elastic
export KIBANA_PASSWORD=changeme
kb-dashboard compile --upload
```

### API Key Authentication

Use a Kibana API key:

```bash
kb-dashboard compile \
  --upload \
  --kibana-api-key "your-base64-encoded-key"
```

Or via environment variable:

```bash
export KIBANA_API_KEY="your-base64-encoded-key"
kb-dashboard compile --upload
```

To create an API key in Kibana:

1. Go to Stack Management → API Keys
2. Click "Create API key"
3. Give it a name and set appropriate privileges
4. Copy the encoded key and use it with the CLI

## Troubleshooting

### Connection Refused

If you get a connection refused error:

- Verify Kibana is running: `curl http://localhost:5601/api/status`
- Check the Kibana URL is correct
- Ensure there are no firewall rules blocking the connection

### Authentication Failed

If you get authentication errors:

- Verify your credentials are correct
- Check that the user has appropriate permissions
- For API keys, ensure the key hasn't expired

### Upload Errors

If objects fail to upload:

- Check the Kibana logs for detailed error messages
- Verify the NDJSON format is valid
- Use `--no-overwrite` if you want to preserve existing objects


---
# Source: vscode-extension.md
---

# VS Code Extension

A Visual Studio Code extension that provides live compilation, preview, and visual editing for Kibana YAML dashboards. This extension makes it fast and easy to work with YAML dashboard files by automatically compiling them on save and providing a live preview with interactive layout editing.

- **Auto-complete and Validation** – Schema-based auto-complete, validation, and hover documentation for YAML dashboard files (powered by Red Hat YAML extension)
- **Code Snippets** – Pre-built snippets for all panel types, controls, and layouts - just start typing a prefix like `panel-lens-metric` and press Tab
- **Auto-compile on Save** – Automatically compiles your YAML dashboard files whenever you save them
- **Live Preview Panel** – View your compiled dashboard in a side-by-side preview panel with live reload
- **Visual Grid Layout Editor** – Drag and drop panels to rearrange them, resize panels interactively, with automatic YAML updates
- **Export to NDJSON** – Copy or download compiled dashboards as NDJSON for direct import into Kibana
- **Error Reporting** – Clear error messages when compilation fails
- **Context Menu Integration** – Right-click commands in YAML files for quick access

## Why Use the Extension?

The VS Code extension is the **easiest way to get started** with the Kibana Dashboard Compiler:

### No Python Installation Required

- **Bundled LSP binary** - Extension includes pre-built server binary for all platforms
- **Zero configuration** - Works immediately after installation
- **No dependency management** - No `pip`, `uv`, or virtual environments needed

### Instant Feedback

- **Live preview** - See your dashboard as you type
- **Auto-compile on save** - Background compilation with error reporting
- **Visual validation** - Schema-based validation catches errors before upload

### Productivity Features

- **Code snippets** - 40+ pre-built snippets for panels, controls, layouts
- **Visual grid editor** - Drag-and-drop panel positioning
- **Schema auto-complete** - IntelliSense for all YAML properties
- **One-click upload** - Direct integration with Kibana

**When to use CLI instead:** CI/CD pipelines, batch processing, scripting, environments without VS Code

---

## Installation

### Prerequisites

#### For End Users (Installing from Registry/VSIX)

- VS Code 1.85.0 or higher
- Red Hat YAML extension (automatically installed)
- **No Python required** - Bundled binary included

#### For Extension Developers Only

- Python 3.12+ with `dashboard_compiler` package
- Node.js 18+ for building the extension
- VS Code 1.85.0 or higher

### Installing the Extension

#### Option 1: Install from OpenVSX Registry

Works with Cursor, VSCodium, and other VS Code forks:

1. Open Extensions view (Ctrl+Shift+X)
2. Search for "Kibana Dashboard Compiler"
3. Click Install

#### Option 2: Manual Installation (VSIX)

For restricted environments or offline installation:

1. Download platform-specific `.vsix` from [releases page](https://github.com/strawgate/kb-yaml-to-lens/releases)
2. In VS Code: Extensions view (Ctrl+Shift+X) → "..." menu → "Install from VSIX..."
3. Select the downloaded `.vsix` file

**That's it!** The extension includes everything needed - no additional setup required.

### Verify Installation

After installation, confirm the extension is working:

1. **Check extension is active:**
   - Open Command Palette (Ctrl+Shift+P / Cmd+Shift+P on Mac)
   - Type "YAML Dashboard" - you should see multiple commands listed

2. **Test snippet functionality:**
   - Create a new file: `test-dashboard.yaml`
   - Type `dashboard` and press Tab
   - A complete dashboard structure should be inserted

3. **Troubleshooting:**
   - If commands don't appear: Restart VS Code
   - If snippets don't work: Ensure file extension is `.yaml`
   - Check Output panel: View → Output → "Kibana Dashboard Compiler"

### For Extension Developers

Only needed if you're developing the extension itself:

1. Build the extension:

   ```bash
   cd vscode-extension
   npm install
   npm run compile
   npm run package
   ```

2. Install in VS Code:
   - Open VS Code
   - Go to Extensions view (Ctrl+Shift+X)
   - Click the "..." menu at the top of the Extensions view
   - Select "Install from VSIX..."
   - Choose the generated `.vsix` file

## Setup

### Extension Configuration

Configure in VS Code settings (File → Preferences → Settings, search for "Kibana Dashboard"):

**`yamlDashboard.compileOnSave`** - Enable/disable automatic compilation on save (default: `true`)

**`yamlDashboard.kibana.url`** - Kibana URL for uploads (default: `http://localhost:5601`)

**`yamlDashboard.kibana.sslVerify`** - Verify SSL certificates (default: `true`)

**`yamlDashboard.kibana.browserType`** - Browser for opening dashboards - `external` or `simple` (default: `external`)

**`yamlDashboard.kibana.openOnSave`** - Auto-upload and open in Kibana on save (default: `false`)

**`yamlDashboard.pythonPath`** - Python interpreter path (optional - only needed for development; bundled binary is used by default)

## Usage

### Commands

The extension provides the following commands (accessible via Command Palette - Ctrl+Shift+P):

- **YAML Dashboard: Compile Dashboard** – Manually compile the current YAML file
- **YAML Dashboard: Preview Dashboard** – Open preview panel for the current YAML file
- **YAML Dashboard: Edit Dashboard Layout** – Open visual grid layout editor for drag-and-drop panel positioning
- **YAML Dashboard: Export Dashboard to NDJSON** – Copy compiled NDJSON to clipboard
- **YAML Dashboard: Open in Kibana** – Upload compiled dashboard to Kibana and open in browser
- **YAML Dashboard: Set Kibana API Key** – Store API credentials for Kibana uploads

## Complete Workflow Walkthrough

### First-Time Setup (5 minutes)

1. **Install the extension** (see Installation section above)
2. **Configure Kibana connection** (optional - only needed for uploads):
   - Open Settings (File → Preferences → Settings)
   - Search: "Kibana Dashboard"
   - Set `yamlDashboard.kibana.url` (e.g., `http://localhost:5601`)
   - Run command: **"YAML Dashboard: Set Kibana API Key"** (recommended) or set username/password

### Daily Development Workflow

1. **Create or open** a YAML dashboard file
2. **Use snippets** for rapid scaffolding:
   - Type `dashboard` + Tab for complete dashboard structure
   - Type `panel-lens-metric` + Tab for metric panel
   - Type `grid-half` + Tab for half-width grid layout
3. **Save (Ctrl+S)** - automatic compilation runs in background
4. **Preview** your work:
   - Command: **"YAML Dashboard: Preview Dashboard"**
   - Panel opens side-by-side with live reload
5. **Visual layout adjustment** (optional):
   - Command: **"YAML Dashboard: Edit Dashboard Layout"**
   - Drag panels to reposition, resize by dragging corners
   - Changes auto-save back to YAML
6. **Upload to Kibana**:
   - Command: **"YAML Dashboard: Open in Kibana"**
   - Dashboard uploads and opens in browser automatically

### Quick Commands Reference

Access via Command Palette (Ctrl+Shift+P):

| Command | Purpose | When to Use |
| ------- | ------- | ----------- |
| **Compile Dashboard** | Manual compilation | After disabling auto-compile |
| **Preview Dashboard** | Open live preview | First time or after closing preview |
| **Edit Dashboard Layout** | Visual grid editor | Positioning panels visually |
| **Export to NDJSON** | Copy to clipboard | Manual Kibana import |
| **Open in Kibana** | Upload + open browser | Deploy to Kibana |
| **Set Kibana API Key** | Store credentials | One-time Kibana setup (recommended) |

### Keyboard Shortcuts

You can add custom keyboard shortcuts in VS Code (File → Preferences → Keyboard Shortcuts):

```json
{
  "key": "ctrl+shift+d",
  "command": "yamlDashboard.preview",
  "when": "resourceLangId == yaml"
}
```

### Preview Panel

The preview panel shows:

- **Dashboard Title** – The title from your YAML configuration
- **File Path** – The current file being previewed
- **Export Buttons**:
  - Copy NDJSON to clipboard
  - Download NDJSON file
- **Dashboard Information** – Type, ID, version
- **Compiled Output** – Pretty-printed JSON view of the compiled dashboard

### Grid Layout Editor

The visual grid layout editor provides an interactive way to arrange your dashboard panels:

- **Drag and Drop** – Click and drag panels to reposition them
- **Resize Panels** – Drag the bottom-right corner to resize
- **Grid System** – Works with Kibana's 48-column grid layout
- **Show Grid Lines** – Toggle grid visibility for easier alignment
- **Snap to Grid** – Enable snapping for precise positioning
- **Auto-save** – Changes are automatically written back to your YAML file

## Importing to Kibana

Once you've compiled your dashboard, you can import it into Kibana:

1. Use the **Copy NDJSON** button in the preview panel
2. In Kibana, navigate to: **Stack Management → Saved Objects → Import**
3. Paste or upload the NDJSON file
4. Your dashboard is now available in Kibana!

## Related Links

- [Main Repository](https://github.com/strawgate/kb-yaml-to-lens)
- [Kibana Lens Documentation](https://github.com/elastic/kibana/tree/main/x-pack/platform/plugins/shared/lens)
- [VS Code Extension API](https://code.visualstudio.com/api)


---
# Source: examples/index.md
---

# Complete Examples

This section provides real-world YAML dashboard examples demonstrating various features and capabilities of the Dashboard Compiler.

## How to Use These Examples

1. **View:** Expand the "Dashboard Definition" section for any example below to see the complete code inline. (Click the section header to expand.)
2. **Copy:** Use the copy button in the expanded code block.
3. **Save:** Save the content to a `.yaml` file in your `inputs/` directory (e.g., `inputs/my_example.yaml`).
4. **Compile:** Run the compiler:

   ```bash
   kb-dashboard compile
   ```

5. **Upload (Optional):** To upload directly to Kibana:

   ```bash
   kb-dashboard compile --upload
   ```

## Available Examples

### Controls Example

Demonstrates the use of dashboard controls including:

- Options list controls for filtering
- Range slider controls
- Time slider controls
- Control chaining and dependencies
- Custom label positions

**Use this when:** You need interactive filtering capabilities on your dashboard.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (controls-example.yaml)"

    ```yaml
    --8<-- "examples/controls-example.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Dimensions Example

Shows how to configure dimensions in Lens visualizations:

- Multiple dimension types
- Custom formatting options
- Breakdown configurations
- Top values and other bucketing strategies

**Use this when:** You're building complex charts with multiple breakdowns and groupings.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (dimensions-example.yaml)"

    ```yaml
    --8<-- "examples/dimensions-example.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Color Palette Example

Demonstrates color customization for charts including:

- Custom color palettes (color-blind safe, Elastic brand, grayscale, legacy)
- **Advanced:** Manual color assignments to specific values
- **Advanced:** Multi-value color grouping
- Per-chart color configuration
- **Advanced:** Color assignments for pie, line, bar, and area charts

**Use this when:** You need to customize chart colors for branding, accessibility, or visual clarity.

**Note:** Manual color assignments are an advanced topic. See the [Custom Color Assignments](../advanced/color-assignments.md) guide for an introduction.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (color-palette-examples.yaml)"

    ```yaml
    --8<-- "examples/color-palette-examples.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Filters Example

Comprehensive filter demonstrations including:

- Field existence filters
- Phrase and phrase list filters
- Range filters (numeric and date)
- Custom DSL filters
- Combined filters with AND/OR/NOT operators
- Panel-level and dashboard-level filters

**Use this when:** You need to pre-filter data or provide context-specific views.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (filters-example.yaml)"

    ```yaml
    --8<-- "examples/filters-example.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Multi-Panel Showcase

A complete dashboard featuring multiple panel types:

- Markdown panels for documentation
- Metric charts for KPIs
- Pie charts for distributions
- XY charts for trends
- Image panels
- Links panels for navigation
- Grid layout examples

**Use this when:** You want to see how different panel types work together in a single dashboard.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (multi-panel-showcase.yaml)"

    ```yaml
    --8<-- "examples/multi-panel-showcase.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Navigation Example

Demonstrates dashboard navigation features:

- Links panels with external and internal navigation
- Dashboard linking patterns
- URL parameter passing
- Navigation best practices

**Use this when:** You're building a suite of interconnected dashboards.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (navigation-example.yaml)"

    ```yaml
    --8<-- "examples/navigation-example.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Aerospike Monitoring Examples

Real-world monitoring dashboards for Aerospike database.

**Use this when:** Monitoring Aerospike NoSQL database deployments.

#### Overview Dashboard

Cluster-level metrics and node health monitoring.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (aerospike/overview.yaml)"

    ```yaml
    --8<-- "examples/aerospike/overview.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Node Metrics

Detailed per-node performance monitoring.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (aerospike/node-metrics.yaml)"

    ```yaml
    --8<-- "examples/aerospike/node-metrics.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Namespace Metrics

Namespace-level storage and query statistics.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (aerospike/namespace-metrics.yaml)"

    ```yaml
    --8<-- "examples/aerospike/namespace-metrics.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### OpenTelemetry System Dashboards

Comprehensive host monitoring dashboards for OpenTelemetry system metrics.

**Use this when:** Monitoring infrastructure with OpenTelemetry Host Metrics Receiver.

**Note:** Based on the [Elastic integrations repository](https://github.com/elastic/integrations/tree/main/packages/system_otel) dashboards. Licensed under [Elastic License 2.0](../licenses/ELASTIC-LICENSE-2.0.txt). Some advanced panels (AI-powered features, legacy visualizations) are excluded as they're not yet supported by the compiler.

#### Hosts Overview

Overview of all hosts with key performance metrics.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (system_otel/01-hosts-overview.yaml)"

    ```yaml
    --8<-- "examples/system_otel/01-hosts-overview.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Host Details - Overview

Detailed single host overview with CPU, memory, and disk metrics.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (system_otel/02-host-details-overview.yaml)"

    ```yaml
    --8<-- "examples/system_otel/02-host-details-overview.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Host Details - Metrics

In-depth metrics charts for CPU, memory, disk, and load.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (system_otel/03-host-details-metrics.yaml)"

    ```yaml
    --8<-- "examples/system_otel/03-host-details-metrics.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Host Details - Metadata

Host resource attributes and metadata (ES|QL datatables).

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (system_otel/04-host-details-metadata.yaml)"

    ```yaml
    --8<-- "examples/system_otel/04-host-details-metadata.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Host Details - Logs

Host log messages (ES|QL datatable).

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (system_otel/05-host-details-logs.yaml)"

    ```yaml
    --8<-- "examples/system_otel/05-host-details-logs.yaml"
    ```
<!-- markdownlint-enable MD046 -->

### Docker OpenTelemetry Dashboards

Docker container monitoring dashboards for OpenTelemetry metrics.

**Use this when:** Monitoring Docker containers with OpenTelemetry Docker Stats Receiver.

**Note:** Based on the [Elastic integrations repository](https://github.com/elastic/integrations/tree/main/packages/docker_otel) dashboards. Licensed under [Elastic License 2.0](../licenses/ELASTIC-LICENSE-2.0.txt).

#### Containers Overview

Multi-container monitoring with CPU, memory, disk I/O, and network metrics.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (docker_otel/01-containers-overview.yaml)"

    ```yaml
    --8<-- "examples/docker_otel/01-containers-overview.yaml"
    ```
<!-- markdownlint-enable MD046 -->

#### Container Stats

Detailed single-container performance analysis and resource utilization.

<!-- markdownlint-disable MD046 -->
??? example "Dashboard Definition (docker_otel/02-container-stats.yaml)"

    ```yaml
    --8<-- "examples/docker_otel/02-container-stats.yaml"
    ```
<!-- markdownlint-enable MD046 -->

## Viewing Example Source Code

All example files are located in the `docs/content/examples/` directory of the repository. You can:

1. **View inline:** Expand any "Dashboard Definition" section above to see the complete YAML code
2. **Clone locally:** Download the repository to experiment with examples
3. **Compile examples:** Run `kb-dashboard compile --input-dir docs/content/examples --output-dir output` to generate NDJSON files

## Using Examples as Templates

To use an example as a starting point for your own dashboard:

1. Copy the example YAML file to your `inputs/` directory
2. Modify the dashboard name, description, and ID
3. Adjust panels, filters, and controls to match your data views
4. Compile and upload to Kibana

## Related Documentation

- [Dashboard Configuration](../dashboard/dashboard.md) - Dashboard-level settings
- [Panel Types](../panels/base.md) - Available panel types and configurations


---
# Source: dashboard/dashboard.md
---

# Dashboard Configuration

The `dashboards` array is the root element in your YAML configuration file. Each dashboard defines the overall structure, content, and global settings for a Kibana dashboard.

## Minimal Configuration Example

A minimal dashboard requires a `name` and at least one panel.

```yaml
dashboards:
  - name: "Simple Log Dashboard"
    panels:
      - markdown:
          content: "Welcome to the dashboard!"
        size: {w: 6, h: 3}
```

## Complex Configuration Example

This example showcases a dashboard with various settings, a global query, filters, controls, and multiple panels.

```yaml
dashboards:
  - name: "Comprehensive Application Overview"
    description: "An overview of application performance and logs, with interactive filtering."
    settings:
      margins: true
      titles: true
      sync:
        cursor: true
        tooltips: true
        colors: false # Use distinct color palettes per panel
      controls:
        label_position: "above"
        chain_controls: true
    query:
      kql: "NOT response_code:500" # Global KQL query
    filters:
      - field: "geo.country_iso_code"
        equals: "US"
      - exists: resource.attributes.host.name
    controls:
      - type: options
        label: "Filter by Host"
        data_view: "metrics-*"
        field: "resource.attributes.host.name"
        width: "medium"
    panels:
      - markdown:
          content: "### Key Performance Indicators"
        size: {w: 12, h: 2}
      - lens:
          type: metric
          primary:
            aggregation: unique_count
            field: resource.attributes.host.name
          data_view: "metrics-*"
        title: "Total Hosts"
        size: {w: 4, h: 4}
        position: {x: 0, y: 2}
      - lens:
          type: bar
          dimension:
            type: values
            field: "resource.attributes.os.type"
          metrics:
            - aggregation: unique_count
              field: resource.attributes.host.name
          data_view: "metrics-*"
        title: "Hosts by OS Type"
        size: {w: 8, h: 4}
        position: {x: 4, y: 2}
```

## Full Configuration Options

### Dashboard Object

The main object defining the dashboard.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `name` | `string` | The title of the dashboard displayed in Kibana. | N/A | Yes |
| `id` | `string` | An optional unique identifier for the dashboard. If not provided, one will be generated based on the name. | Generated ID | No |
| `description` | `string` | A brief description of the dashboard's purpose or content. | `""` (empty string) | No |
| `time_range` | `TimeRange` object | A default time range to apply when opening the dashboard. See [Time Range](#time-range-time_range). | `None` | No |
| `settings` | `DashboardSettings` object | Global settings for the dashboard. See [Dashboard Settings](#dashboard-settings-settings). | See defaults below | No |
| `query` | `Query` object | A global query (KQL or Lucene) applied to the dashboard. See [Queries Documentation](../queries/config.md). | `None` | No |
| `filters` | `list of Filter objects` | A list of global filters applied to the dashboard. See [Filters Documentation](../filters/config.md). | `[]` (empty list) | No |
| `controls` | `list of Control objects` | A list of control panels for the dashboard. See [Controls Documentation](../controls/config.md). | `[]` (empty list) | No |
| `panels` | `list of Panel objects` | A list of Panel objects defining the content and layout. See [Panels Documentation](../panels/base.md). | `[]` (empty list) | Yes |

### Time Range (`time_range`)

Configure a default time range that will be restored when opening the dashboard. When `time_range` is set, Kibana will automatically apply the specified time range instead of using the global time picker value.

| YAML Key | Data Type | Description | Default | Required |
| -------- | --------- | ----------- | ------- | -------- |
| `from` | `string` | The start of the time range. Supports relative time expressions like `now-30d/d`, `now-1h`, etc. | N/A | Yes |
| `to` | `string` | The end of the time range. Supports relative time expressions. | `now` | No |

**Example:**

```yaml
dashboards:
  - name: "Last 30 Days Overview"
    time_range:
      from: "now-30d/d"
      to: "now"
    panels:
      - markdown:
          content: "This dashboard defaults to the last 30 days."
        size: {w: 12, h: 3}
```

### Dashboard Settings (`settings`)

Global settings for the dashboard, configured under the `dashboard.settings` path.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `margins` | `boolean` | Whether to put space (margins) between panels in the dashboard. | `true` | No |
| `sync` | `DashboardSyncSettings` object | Configures synchronization of cursor, tooltips, and colors across panels. See [Dashboard Sync Settings](#dashboard-sync-settings-settingssync). | See defaults below | No |
| `controls` | `ControlSettings` object | Global settings for controls on the dashboard. See [Controls Documentation](../controls/config.md#control-settings-settingscontrols). | See defaults in Controls docs | No |
| `titles` | `boolean` | Whether to display the titles in the panel headers. | `true` | No |

### Dashboard Sync Settings (`settings.sync`)

Configure whether cursor, tooltips, and colors should synchronize across panels.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------- | --------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `cursor` | `boolean` | Whether to synchronize the cursor across related panels. | `true` | No |
| `tooltips` | `boolean` | Whether to synchronize tooltips across related panels. | `true` | No |
| `colors` | `boolean` | Whether to apply the same color palette to all panels on the dashboard. | `true` | No |

## Methods (for programmatic generation)

While primarily declarative, the underlying Pydantic models for `Dashboard` support methods for adding components if you are generating configurations programmatically (not directly used in YAML):

* `add_filter(filter: FilterTypes)`: Adds a filter to the `filters` list.
* `add_control(control: ControlTypes)`: Adds a control to the `controls` list.
* `add_panel(panel: PanelTypes)`: Adds a panel to the `panels` list.

## Related Documentation

* [Controls Configuration](../controls/config.md)
* [Filters Configuration](../filters/config.md)
* [Queries Configuration](../queries/config.md)
* [Panels Overview](../panels/base.md)


---
# Source: panels/base.md
---

# Base Panel Configuration

All panel types used within a dashboard (e.g., Markdown, Lens charts, Search panels) share a common set of base configuration fields. These fields define fundamental properties like the panel's title, its position and size on the dashboard grid, and an optional description.

When defining a panel in your YAML, you must specify the configuration block for that specific panel type (e.g., `markdown`, `lens`) which serves as the key to identify the panel type.

## A Poem for the Dashboard Builders

_For those who lay the foundation for every panel:_

```text
Every panel needs a base:
A title, grid, and proper place.
From x and y, the starting spot,
To width and height—you plot the plot.

The id is yours, or auto-made,
Descriptions help when things must be weighed.
hide_title when you'd rather not—
The base provides what others forgot.

Whether metric, pie, or chart XY,
Markdown prose or links nearby,
They all inherit from this floor:
The BasePanel, forevermore.

So here's to grids that organize,
To coordinates that plot the prize.
The humble base, unsexy but true—
No panel works without you.
```

---

## Minimal Example (Illustrating Base Fields within a Specific Panel Type)

This example shows how base panel fields are used within a `markdown` panel:

```yaml
dashboards:
- name: "Example Dashboard"
  panels:
    - markdown:
        content: "System is **operational**." # MarkdownPanel specific config
      title: "Status Overview"
      description: "A quick look at system status." # BasePanel field
      hide_title: false                             # BasePanel field
      size:                                         # BasePanel field (recommended)
        w: quarter  # or numeric value like 12
        h: 8
      position:                                     # BasePanel field (optional)
        x: 0
        y: 0
```

**Note:** See [Auto-Layout Guide](./auto-layout.md) for details on automatic panel positioning.

## Full Configuration Options

### Base Panel Fields

These fields are available for all panel types and are inherited from the `BasePanel` configuration.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------ | --------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------- | -------- |
| `id` | `string` | A unique identifier for the panel. If not provided, one may be generated during compilation. | Generated ID | No |
| `title` | `string` | The title displayed on the panel header. Can be an empty string if you wish for no visible title. | `""` (empty string) | No |
| `hide_title` | `boolean` | If `true`, the panel title (even if defined) will be hidden. | `false` (title is shown) | No |
| `description` | `string` | A brief description of the panel's content or purpose. This is often shown on hover or in panel information. | `""` (empty string, if `None`) | No |
| `size` | `Size` object | Defines the panel's width and height. See [Size Object Configuration](#size-object-configuration-size) below. | `w: 12, h: 8` | No |
| `position` | `Position` object | **Optional:** Defines the panel's x/y coordinates. Omit for automatic positioning. See [Position Object Configuration](#position-object-configuration-position) below. | Auto-calculated | No |

**Note on Panel Types**: Each panel must have exactly one key identifying its type (e.g., `markdown`, `lens`, `search`, `links`, `image`, `esql`). This key contains the type-specific configuration.

**Note on Auto-Layout**: For automatic panel positioning without manual coordinate calculation, use the `size` field and omit the `position` field. See the [Auto-Layout Guide](./auto-layout.md) for details.

### Size Object Configuration (`size`)

The `size` object defines the panel's width and height on the dashboard grid. This is the **recommended** approach for new dashboards.

Both shorthand and verbose parameter names are supported for improved readability.

| YAML Key | Verbose Alternative | Data Type | Description | Default | Required |
| -------- | ------------------- | --------- | ------------------------------------------------------------ | ------- | -------- |
| `w` | `width` | `integer` or `SemanticWidth` | The width of the panel. Accepts semantic values (`whole`, `half`, `third`, `quarter`, `sixth`, `eighth`) or numeric values (1-48). | `12` (quarter) | No |
| `h` | `height` | `integer` | The height of the panel in grid units. | `8` | No |

**Semantic Width Values:**

| Value | Grid Units | Description |
| ----- | ---------- | ----------- |
| `whole` | 48 | Full dashboard width |
| `half` | 24 | Half width |
| `third` | 16 | One-third width |
| `quarter` | 12 | Quarter width |
| `sixth` | 8 | One-sixth width |
| `eighth` | 6 | One-eighth width |

**Example:**

```yaml
size:
  w: quarter  # Semantic value
  h: 8

# Or with numeric value:
size:
  width: 24   # Numeric value
  height: 12
```

### Position Object Configuration (`position`)

The `position` object defines the panel's x/y coordinates on the dashboard grid. This field is **optional** - when omitted, the panel will be automatically positioned using the dashboard's layout algorithm.

| YAML Key | Verbose Alternative | Data Type | Description | Default | Required |
| -------- | ------------------- | --------- | ------------------------------------------------------------ | ------- | -------- |
| `x` | `from_left` | `integer` or `None` | The horizontal starting position (0-based, 0-48). If `None`, position is auto-calculated. | `None` | No |
| `y` | `from_top` | `integer` or `None` | The vertical starting position (0-based). If `None`, position is auto-calculated. | `None` | No |

**Example with fixed position:**

```yaml
position:
  x: 0
  y: 0

# Or verbose:
position:
  from_left: 24
  from_top: 10
```

**Example with auto-positioning (omit position entirely):**

```yaml
# No position field - will be auto-positioned
size:
  w: quarter
  h: 8
```

## Panel Types (Specific Configurations)

The `BasePanel` fields are common to all panel types. For details on the specific configuration fields available for each panel `type`, refer to their individual documentation pages:

* [Markdown Panel](./markdown.md)
* [Links Panel](./links.md)
* [Search Panel](./search.md)
* [Image Panel](./image.md)
* [XY Chart Panel](./xy.md)
* [Pie Chart Panel](./pie.md)
* [Metric Panel](./metric.md)
* [Tagcloud Panel](./tagcloud.md)
* [Lens Panel](./lens.md)
* [ESQL Panel](./esql.md)

## Color Mapping Configuration

> **Quick Reference**: Want to customize chart colors? See [Color Mapping Examples](#color-mapping-examples) below for palette selection, or the [Custom Color Assignments](../advanced/color-assignments.md) guide for manual color assignments.

Many chart panel types (Pie, XY, Metric) support color customization through the `color` field. You can select from built-in color palettes or manually assign specific colors to data values.

### ColorMapping Object

::: dashboard_compiler.panels.charts.base.config.ColorMapping
    options:
      show_root_heading: false
      heading_level: 4

### ColorAssignment Object

Manual color assignments are an advanced feature. For an introduction and examples, see the [Custom Color Assignments](../advanced/color-assignments.md) guide.

::: dashboard_compiler.panels.charts.base.config.ColorAssignment
    options:
      show_root_heading: false
      heading_level: 4

### Color Mapping Examples

#### Example 1: Using a Different Palette

```yaml
dashboards:
  - name: "Sales Dashboard"
    panels:
      - title: "Revenue by Region"
        size: { w: 6, h: 6 }
        lens:
          type: pie
          data_view: "logs-*"
          dimensions:
            - field: "region"
              type: values
          metrics:
            - aggregation: sum
              field: revenue
          color:
            palette: 'elastic_brand'  # Use Elastic brand colors
```

#### Example 2: Manual Color Assignments (Advanced)

For a detailed introduction to color assignments, see the [Custom Color Assignments](../advanced/color-assignments.md) guide.

```yaml
dashboards:
  - name: "Status Monitoring"
    panels:
      - title: "Request Status Distribution"
        size: { w: 6, h: 6 }
        lens:
          type: pie
          data_view: "logs-*"
          dimensions:
            - field: "http.response.status_code"
              type: values
          metrics:
            - aggregation: count
          color:
            palette: 'eui_amsterdam_color_blind'
            assignments:
              - values: ['200', '201', '204']
                color: '#00BF6F'  # Green for success
              - values: ['404']
                color: '#FFA500'  # Orange for not found
              - values: ['500', '502', '503']
                color: '#BD271E'  # Red for errors
```

## Related Documentation

* [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/auto-layout.md
---

# Auto-Layout Guide

This guide explains how to use the automatic panel layout system to position panels on your dashboard without manually specifying coordinates.

## Overview

Instead of manually calculating x and y coordinates for every panel, you can use auto-layout to automatically position panels on the dashboard grid. Auto-layout works by:

1. Defining panel **size** (width and height) without position
2. Choosing a **layout algorithm** to determine how panels are arranged
3. Letting the compiler calculate optimal positions for all panels

## Quick Start

### Basic Auto-Layout Example

```yaml
dashboards:
  - name: "Auto-Layout Dashboard"
    settings:
      layout_algorithm: up-left  # Optional, defaults to 'up-left'
    panels:
      # Panel 1: Quarter-width panel (12 units wide)
      - markdown:
          content: "First panel"
        title: "Panel 1"
        size:
          w: quarter  # Semantic width - 12 units
          h: 8        # Height in grid units
        # No position specified - will be auto-positioned

      # Panel 2: Another quarter-width panel
      - markdown:
          content: "Second panel"
        title: "Panel 2"
        size:
          w: quarter
          h: 8

      # Panel 3: Half-width panel
      - markdown:
          content: "Third panel"
        title: "Panel 3"
        size:
          w: half  # Semantic width - 24 units
          h: 8
```

This creates a dashboard where panels are automatically arranged in a 2x2 grid pattern.

## Panel Size Configuration

### The `size` Field

Instead of specifying a `grid` object with x, y, w, h coordinates, you can use separate `size` and `position` fields:

```yaml
panels:
  - markdown:
      content: "My content"
    title: "My Panel"
    size:
      w: 24     # Width (or use semantic values)
      h: 8      # Height
    position:   # Optional - omit for auto-layout
      x: 0
      y: 0
```

### Semantic Width Values

The `w` (width) field accepts semantic values for common panel widths:

| Semantic Value | Grid Units | Description |
| -------------- | ---------- | ----------- |
| `whole` | 48 | Full dashboard width |
| `half` | 24 | Half width (2 panels per row) |
| `third` | 16 | One-third width (3 panels per row) |
| `quarter` | 12 | Quarter width (4 panels per row) |
| `sixth` | 8 | One-sixth width (6 panels per row) |
| `eighth` | 6 | One-eighth width (8 panels per row) |

You can also specify numeric values from 1 to 48.

### Default Size

If you omit the `size` field entirely, panels default to:

- Width: 12 units (quarter width)
- Height: 8 units

```yaml
panels:
  - markdown:
      content: "Uses default size"
    title: "Default Panel"
    # No size specified - uses w=12, h=8
```

## Layout Algorithms

The `layout_algorithm` setting in dashboard `settings` controls how panels are automatically positioned. Choose the algorithm that best fits your dashboard's content flow.

### `up-left` (Default)

Floats panels up first, then left. Creates compact, grid-like layouts.

**Best for:** Dashboards where you want panels to form neat grids.

```yaml
dashboards:
  - name: "Up-Left Example"
    settings:
      layout_algorithm: up-left
    panels:
      - markdown: { content: "A" }
        title: "Panel A"
        size: { w: quarter, h: 8 }

      - markdown: { content: "B" }
        title: "Panel B"
        size: { w: quarter, h: 8 }

      - markdown: { content: "C" }
        title: "Panel C"
        size: { w: quarter, h: 8 }

      - markdown: { content: "D" }
        title: "Panel D"
        size: { w: quarter, h: 8 }
```

**Result:** Forms a 2x2 grid with panels arranged like:

```text
[A][B]
[C][D]
```

### `left-right`

Fills rows from left to right before moving to the next row. Row height is determined by the tallest panel in that row.

**Best for:** Dashboards where you want panels to appear in reading order (left-to-right, top-to-bottom).

```yaml
dashboards:
  - name: "Left-Right Example"
    settings:
      layout_algorithm: left-right
    panels:
      - markdown: { content: "A" }
        size: { w: half, h: 8 }

      - markdown: { content: "B" }
        size: { w: half, h: 12 }  # Taller panel

      - markdown: { content: "C" }
        size: { w: third, h: 8 }

      - markdown: { content: "D" }
        size: { w: third, h: 8 }
```

**Result:**

```text
Row 1: [A (h=8)][B (h=12)]  <- Row height = 12
Row 2: [C (h=8)][D (h=8)]   <- Row height = 8
```

### `blocked`

Never fills gaps above the current bottom. Maintains strict top-to-bottom flow.

**Best for:** Dashboards where vertical ordering matters more than space efficiency.

```yaml
dashboards:
  - name: "Blocked Example"
    settings:
      layout_algorithm: blocked
    panels:
      - markdown: { content: "Tall panel" }
        size: { w: half, h: 20 }
        position: { x: 0, y: 0 }  # Locked position

      - markdown: { content: "Auto panel 1" }
        size: { w: half, h: 8 }
        # Will go to x=24, y=0 (right of tall panel)

      - markdown: { content: "Auto panel 2" }
        size: { w: half, h: 8 }
        # Will go to y=20 (below the tall panel, not filling the gap)
```

### `first-available-gap`

Scans the entire grid from top-left to find the first available gap. Maximizes space utilization.

**Best for:** Dashboards where minimizing vertical height is important.

```yaml
dashboards:
  - name: "First Available Gap Example"
    settings:
      layout_algorithm: first-available-gap
    panels:
      - markdown: { content: "Tall panel" }
        size: { w: half, h: 20 }
        position: { x: 0, y: 0 }

      - markdown: { content: "Small panel 1" }
        size: { w: half, h: 8 }
        # Will fill the gap at x=24, y=0

      - markdown: { content: "Small panel 2" }
        size: { w: half, h: 8 }
        # Will fill the gap at x=24, y=8
```

## Mixing Auto-Layout and Fixed Positions

You can mix panels with auto-layout and panels with fixed positions (called "locked panels"):

```yaml
dashboards:
  - name: "Mixed Layout"
    panels:
      # Locked panel - fixed position
      - markdown:
          content: "This stays at the top"
        title: "Header"
        size: { w: whole, h: 4 }
        position: { x: 0, y: 0 }

      # Auto-positioned panels will flow around the locked panel
      - markdown:
          content: "Auto panel 1"
        title: "Panel 1"
        size: { w: half, h: 8 }
        # No position - will be auto-positioned below the header

      - markdown:
          content: "Auto panel 2"
        title: "Panel 2"
        size: { w: half, h: 8 }
```

The auto-layout algorithm respects locked panels and positions auto panels around them.

## Field Aliases

Both `size` and `position` support verbose aliases for readability:

```yaml
size:
  width: 24   # Same as 'w'
  height: 12  # Same as 'h'

position:
  from_left: 0  # Same as 'x'
  from_top: 10  # Same as 'y'
```

## Common Patterns

### Full-Width Header with Grid Below

```yaml
panels:
  # Header
  - markdown: { content: "Dashboard Title" }
    title: "Header"
    size: { w: whole, h: 4 }

  # Grid of metrics (will auto-arrange in 2x2 grid)
  - lens: { type: metric, ... }
    size: { w: quarter }

  - lens: { type: metric, ... }
    size: { w: quarter }

  - lens: { type: metric, ... }
    size: { w: quarter }

  - lens: { type: metric, ... }
    size: { w: quarter }
```

### Two-Column Layout

```yaml
settings:
  layout_algorithm: left-right

panels:
  - markdown: { content: "Left column content" }
    size: { w: half, h: 20 }

  - markdown: { content: "Right column content" }
    size: { w: half, h: 20 }

  # These will form the second row
  - markdown: { content: "Bottom left" }
    size: { w: half, h: 10 }

  - markdown: { content: "Bottom right" }
    size: { w: half, h: 10 }
```

### Dashboard with Sidebar

```yaml
panels:
  # Fixed sidebar
  - links: { ... }
    title: "Navigation"
    size: { w: eighth, h: 40 }
    position: { x: 0, y: 0 }  # Lock to left side

  # Main content area (auto-positioned to the right)
  - lens: { type: xy, ... }
    title: "Main Chart"
    size: { w: 42, h: 20 }  # 48 - 6 = 42 remaining width

  - lens: { type: metric, ... }
    size: { w: 42, h: 20 }
```

## Related Documentation

- [Base Panel Configuration](./base.md) - Common panel fields
- [Dashboard Configuration](../dashboard/dashboard.md) - Dashboard settings


---
# Source: panels/links.md
---

# Links Panel Configuration

The `links` panel type is used to display a collection of hyperlinks on your dashboard. These links can point to other Kibana dashboards or external web URLs. This panel is useful for creating navigation hubs or providing quick access to related resources.

## A Poem for the Portal Keepers

_For those who build the bridges between dashboards:_

```text
Portals to dashboards near and far—
Links will take you where they are.
Horizontal rows or vertical stacks,
Teleporting users through the cracks.

Dashboard links with time preserved,
Filters carried, context preserved.
External URLs in tabs brand new,
Wiki pages, docs to pull you through.

"with_time: true" keeps your clock alive,
"with_filters" helps context survive.
What you selected stays in place
As you traverse from space to space.

From the ops hub to service views,
Your links provide the crucial clues.
No more wandering, lost and stressed—
Click once, arrive. You know the rest.
```

---

## Links Panel

::: dashboard_compiler.panels.links.config.LinksPanel
    options:
      show_root_heading: false
      heading_level: 2

## Links Panel Configuration

::: dashboard_compiler.panels.links.config.LinksPanelConfig
    options:
      show_root_heading: false
      heading_level: 3

## Link Types

### Dashboard Link

::: dashboard_compiler.panels.links.config.DashboardLink
    options:
      show_root_heading: false
      heading_level: 4

### URL Link

::: dashboard_compiler.panels.links.config.UrlLink
    options:
      show_root_heading: false
      heading_level: 4

## Related Documentation

* [Base Panel Configuration](./base.md)
* [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/markdown.md
---

# Markdown Panel Configuration

The `markdown` panel type is used to display rich text content, formatted using Markdown syntax, directly on your dashboard. This is equivalent to the "Text" visualization in Kibana.

## A Poem for the Documentation Devotees

_For those who believe every dashboard needs context:_

```text
# Bold headers and *italic* flair,
- Bullet lists with items to share,
[Links](that take you anywhere),
Markdown panels handle with care!

When charts alone won't tell the tale,
And metrics need context to prevail,
You write instructions, notes, and more,
To help users understand the score.

"## Welcome to this Dashboard space!"
"Please follow these steps with grace!"
Font size twelve or twenty-four,
Open a new tab, or replace this bore.

From setup guides to troubleshooting tips,
Important warnings, helpful quips,
Your markdown keeps the team aligned,
Thanks to documentation found in-line!
```

---

## Markdown Panel

::: dashboard_compiler.panels.markdown.config.MarkdownPanel
    options:
      show_root_heading: false
      heading_level: 2

## Markdown Panel Configuration

::: dashboard_compiler.panels.markdown.config.MarkdownPanelConfig
    options:
      show_root_heading: false
      heading_level: 3

## Related Documentation

* [Base Panel Configuration](./base.md)
* [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/lens.md
---

# Lens Panel Configuration

Lens panels in Kibana provide a flexible and user-friendly way to create various types of visualizations, such as metric displays, pie charts, bar charts, line charts, and more. This document covers the YAML configuration for Lens panels using this compiler.

The `LensPanel` is the primary container. Its `chart` field will define the specific type of visualization (e.g., `metric`, `pie`).

## A Poem for the Lens Pioneers

_For those who craft visualizations with elegant flexibility:_

```text
Through this Lens we magnify
Patterns hiding oh so sly.
From metrics bold to pies that slice,
Lens makes your data look quite nice!

Dimensions group and metrics measure,
Aggregations are your treasure.
count(), sum(), and unique_count() too,
Percentiles show p95 to you.

Date histograms go back in time,
Top values sorted, so sublime.
Formulas for custom math—
Lens blazes the perfect path!

With data views and layers deep,
Finally, a dashboard you'll keep.
So here's to Lens, a beauty so true:
That nobody can take away from you.
```

---

## Minimal Configuration Examples

**Minimal Lens Metric Chart:**

```yaml
dashboards:
  - name: "Key Metrics Dashboard"
    panels:
      - title: "Total Users"
        size: {w: 16, h: 3}
        lens:
          type: metric # Specifies a LensMetricChart
          data_view: "logs-*"
          query: # Optional panel-specific query
            kql: "event.dataset:website.visits"
          primary:
            aggregation: "unique_count"
            field: "user.id"
            label: "Unique Visitors"
```

**Minimal Lens Pie Chart:**

```yaml
dashboards:
  - name: "Traffic Analysis"
    panels:
      - title: "Traffic by Source"
        size: {w: 32, h: 3}
        position: {x: 16, y: 0}
        lens:
          type: pie # Specifies a LensPieChart
          data_view: "weblogs-*"
          metrics:
            - aggregation: "count"
              label: "Sessions"
          dimensions:
            - type: values
              field: "source.medium"
              label: "Traffic Source"
              size: 5 # Top 5 sources
```

## Full Configuration Options

### Lens Panel (`type: charts`)

This is the main object for a Lens-based visualization. It inherits from the [Base Panel Configuration](base.md).

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ------------------------------- | -------- |
| `type` | `Literal['charts']` | Specifies the panel type as a Lens panel. | `charts` | Yes |
| `id` | `string` | A unique identifier for the panel. Inherited from BasePanel. | Generated ID | No |
| `title` | `string` | The title displayed on the panel header. Inherited from BasePanel. | `""` (empty string) | No |
| `hide_title` | `boolean` | If `true`, the panel title will be hidden. Inherited from BasePanel. | `false` | No |
| `description` | `string` | A brief description of the panel. Inherited from BasePanel. | `""` (empty string, if `None`) | No |
| `size` | `Size` object | Defines the panel's width and height. Inherited from BasePanel. See [Size Object Configuration](base.md#size-object-configuration-size). | `w: 12, h: 8` | No |
| `position` | `Position` object | Defines the panel's x/y coordinates. Inherited from BasePanel. See [Position Object Configuration](base.md#position-object-configuration-position). | Auto-calculated | No |
| `query` | `LegacyQueryTypes` object (KQL or Lucene) | A panel-specific query to filter data for this Lens visualization. See [Queries Documentation](../queries/config.md). | `None` (uses dashboard query) | No |
| `filters` | `list of FilterTypes` | A list of panel-specific filters. See [Filters Documentation](../filters/config.md). | `[]` (empty list) | No |
| `chart` | `LensChartTypes` object | Defines the actual Lens visualization configuration. This will be one of [Lens Metric Chart](#lens-metric-chart-charttype-metric) or [Lens Pie Chart](#lens-pie-chart-charttype-pie). | N/A | Yes |

**Note**: For XY charts (line, bar, area), a `layers` field is available to add reference lines and additional data layers. See the [XY Chart Panel Configuration](xy.md#reference-lines) documentation for details.

---

## Lens Metric Chart (`chart.type: metric`)

Displays a single primary metric, optionally with a secondary metric, a maximum value, and a breakdown dimension.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['metric']` | Specifies the chart type as a Lens Metric visualization. | `metric` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `primary` | `LensMetricTypes` object | The primary metric to display. This is the main value shown. See [Lens Metrics](#lens-metrics-primary-secondary-maximum-for-metric-metrics-for-pie). | N/A | Yes |
| `secondary` | `LensMetricTypes` object | An optional secondary metric to display alongside the primary. See [Lens Metrics](#lens-metrics-primary-secondary-maximum-for-metric-metrics-for-pie). | `None` | No |
| `maximum` | `LensMetricTypes` object | An optional maximum metric, often used for context (e.g., showing a value out of a total). See [Lens Metrics](#lens-metrics-primary-secondary-maximum-for-metric-metrics-for-pie). | `None` | No |
| `breakdown` | `LensDimensionTypes` object | An optional dimension to break down the metric by (e.g., showing primary metric per country). See [Lens Dimensions](#lens-dimensions-breakdown-for-metric-dimensions-for-pie). | `None` | No |

**Example (Lens Metric Chart):**

```yaml
dashboards:
  - name: "Lens Metric Example"
    description: "Example of Lens metric panel with primary, secondary, and breakdown"
    panels:
      - title: "Data Transfer Metrics"
        size: {w: 24, h: 15}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            aggregation: "sum"
            field: "bytes_transferred"
            label: "Total Data"
            format: { type: "bytes" }
          secondary:
            aggregation: "average"
            field: "response_time_ms"
            label: "Avg Response"
            format: { type: "duration", suffix: " ms" }
          breakdown:
            type: values
            field: "host.name"
            size: 3
            label: "Top Hosts"
```

---

## Lens Pie Chart (`chart.type: pie`)

Visualizes proportions of categories using slices of a pie or a donut chart.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['pie']` | Specifies the chart type as a Lens Pie visualization. | `pie` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `data_view` | `string` | The ID or title of the data view (index pattern) for this pie chart. | N/A | Yes |
| `metrics` | `LensMetricTypes \| list[LensMetricTypes]` object | A single metric or list of metrics that determine the size of each slice. See [Lens Metrics](#lens-metrics-primary-secondary-maximum-for-metric-metrics-for-pie). | N/A | Yes |
| `dimensions` | `list of LensDimensionTypes` objects | One or more dimensions that determine how the pie is sliced. See [Lens Dimensions](#lens-dimensions-breakdown-for-metric-dimensions-for-pie). | N/A | Yes |
| `appearance` | `PieChartAppearance` object | Formatting options for the chart appearance. See [Pie Chart Appearance](#pie-chart-appearance-appearance-field). | `None` | No |
| `titles_and_text` | `PieTitlesAndText` object | Formatting options for slice labels and values. See [Pie Titles and Text](#pie-titles-and-text-titles_and_text-field). | `None` | No |
| `legend` | `PieLegend` object | Formatting options for the chart legend. See [Pie Legend](#pie-legend-legend-field). | `None` | No |
| `color` | `ColorMapping` object | Formatting options for the chart color palette. See [Color Mapping](#color-mapping-color-field). | `None` | No |

**Example (Lens Pie Chart):**

```yaml
dashboards:
  - name: "Lens Pie Chart Example"
    description: "Example of Lens pie chart with appearance and legend options"
    panels:
      - title: "Disk Operations by Device"
        size: {w: 24, h: 15}
        lens:
          type: pie
          data_view: "metrics-*"
          metrics:
            - aggregation: "average"
              field: "metrics.system.disk.operations"
              label: "Avg Disk Operations"
          dimensions:
            - type: values
              field: "resource.attributes.device"
              size: 5
              label: "Device"
          appearance:
            donut: "medium"
          legend:
            visible: "show"
            width: "large"
          titles_and_text:
            slice_labels: "inside"
            slice_values: "percent"
```

---

## Lens Dimensions (`breakdown` for Metric, `dimensions` for Pie)

Dimensions define how data is grouped or bucketed in Lens visualizations.

### Common Dimension Fields (`BaseLensDimension`)

All specific dimension types below can include:

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | --------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `id` | `string` | An optional unique identifier for the dimension. | Generated ID | No |
| `label` | `string` | A custom display label for the dimension. If not provided, a label is inferred. | Inferred | No |

### Top Values Dimension (`type: values`)

Groups data by the most frequent unique values of one or more fields. Supports both single-field and multi-field (multi-term) aggregations.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------------ | ----------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['values']` | Specifies the dimension type. | N/A | Yes |
| `field` | `string` | Single field to get top values from. Mutually exclusive with `fields`. | N/A | One of `field` or `fields` |
| `fields` | `list of strings` | Multiple fields for multi-term aggregation (minimum 2 fields). Mutually exclusive with `field`. | N/A | One of `field` or `fields` |
| `size` | `integer` | The number of top values to display. | `3` | No |
| `sort` | `Sort` object | How to sort the terms. `by` can be a metric label or `_term` (alphabetical). `direction` is `asc` or `desc`. | Sort by metric, `desc` | No |
| `other_bucket` | `boolean` | If `true`, groups remaining values into an "Other" bucket. | `true` | No |
| `missing_bucket` | `boolean` | If `true`, creates a bucket for documents where the field is missing. | `false` | No |
| `include` | `list of strings` | A list of specific terms to include. | `None` | No |
| `exclude` | `list of strings` | A list of specific terms to exclude. | `None` | No |
| `include_is_regex` | `boolean` | If `true`, treats `include` values as regex patterns. | `false` | No |
| `exclude_is_regex` | `boolean` | If `true`, treats `exclude` values as regex patterns. | `false` | No |

**Example - Single Field:**

```yaml
dimensions:
  - type: values
    field: agent.name
    size: 5
```

**Example - Multi-Field:**

```yaml
dimensions:
  - type: values
    fields:
      - agent.name
      - agent.type
    size: 10
    label: "Agent Name + Type"
```

### Date Histogram Dimension (`type: date_histogram`)

Groups data into time-based buckets (e.g., per hour, day).

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['date_histogram']` | Specifies the dimension type. | N/A | Yes |
| `field` | `string` | The date field to use for the histogram. | N/A | Yes |
| `minimum_interval` | `string` | The time interval (e.g., `auto`, `1h`, `1d`, `1w`). | `auto` | No |
| `partial_intervals` | `boolean` | If `true`, includes buckets for time periods that are only partially covered by the data. | `true` | No |
| `collapse` | `CollapseAggregationEnum` | For stacked charts, how to aggregate values within the same time bucket if multiple series exist. (`sum`, `min`, `max`, `avg`) | `None` | No |

### Filters Dimension (`type: filters`)

Creates buckets based on a list of custom KQL/Lucene queries.

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['filters']` | Specifies the dimension type. | N/A | Yes |
| `filters` | `list of LensFiltersDimensionFilter` objects | A list of filter definitions. Each filter object has `query` (KQL/Lucene) and an optional `label`. | N/A | Yes |

**`LensFiltersDimensionFilter` Object:**

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------- | ------------------------------------------------ | ---------------- | -------- |
| `query` | `LegacyQueryTypes` object | The KQL or Lucene query for this filter bucket. | N/A | Yes |
| `label` | `string` | A display label for this filter bucket. | Query string | No |

### Intervals Dimension (`type: intervals`)

Groups data into numeric ranges (buckets).

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['intervals']` | Specifies the dimension type. | N/A | Yes |
| `field` | `string` | The numeric field to create intervals from. | N/A | Yes |
| `intervals` | `list of LensIntervalsDimensionInterval` objects | A list of custom interval ranges. If not provided, `granularity` is used. | `None` | No |
| `granularity` | `integer` (1-7) | Divides the field into evenly spaced intervals. 1 is coarsest, 7 is finest. | `4` | No |
| `collapse` | `CollapseAggregationEnum` | For stacked charts, how to aggregate values within the same interval if multiple series exist. (`sum`, `min`, `max`, `avg`) | `None` | No |
| `empty_bucket` | `boolean` | If `true`, shows a bucket for documents with missing values for the field. | `false` | No |

**`LensIntervalsDimensionInterval` Object:**

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | --------- | ------------------------------------------------ | ---------------- | -------- |
| `from` | `integer` | The start of the interval (inclusive). | `None` | No |
| `to` | `integer` | The end of the interval (exclusive). | `None` | No |
| `label` | `string` | A display label for this interval bucket. | Auto-generated | No |

---

## Lens Metrics (`primary`, `secondary`, `maximum` for Metric; `metrics` for Pie)

Metrics define the calculations performed on your data (e.g., count, sum, average).

### Common Metric Fields (`BaseLensMetric`)

All specific metric types below can include:

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `id` | `string` | An optional unique identifier for the metric. | Generated ID | No |
| `label` | `string` | A custom display label for the metric. If not provided, a label is inferred. | Inferred | No |
| `format` | `LensMetricFormatTypes` object | How to format the metric's value (e.g., number, bytes, percent). See [Metric Formatting](#metric-formatting-format-field-within-a-metric). | Default for type | No |
| `filter` | `LegacyQueryTypes` object | A KQL or Lucene query to filter data _before_ this metric is calculated. | `None` | No |

### Aggregated Metric Types

These metrics perform an aggregation on a field.

**Count / Unique Count (`aggregation: count` or `aggregation: unique_count`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['count', 'unique_count']` | Type of count. | N/A | Yes |
| `field` | `string` | For `unique_count`, the field whose unique values are counted. For `count`, optional (counts all documents if `None`). | `None` for `count` | No (Yes for `unique_count`) |
| `exclude_zeros` | `boolean` | If `true`, zero values are excluded from the aggregation. | `true` | No |

**Sum (`aggregation: sum`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['sum']` | Specifies sum aggregation. | `sum` | Yes |
| `field` | `string` | The numeric field to sum. | N/A | Yes |
| `exclude_zeros` | `boolean` | If `true`, zero values are excluded from the sum. | `true` | No |

**Min, Max, Average, Median (`aggregation: min` / `max` / `average` / `median`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['min', 'max', 'average', 'median']` | The aggregation type. | N/A | Yes |
| `field` | `string` | The numeric field for the aggregation. | N/A | Yes |

**Last Value (`aggregation: last_value`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['last_value']` | Retrieves the most recent value of a field. | `last_value` | Yes |
| `field` | `string` | The field whose last value is retrieved. | N/A | Yes |
| `date_field` | `string` | The date field used to determine the "last" value. | `@timestamp` | No |

**Percentile (`aggregation: percentile`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['percentile']` | Calculates the value at a specific percentile. | `percentile` | Yes |
| `field` | `string` | The numeric field for percentile calculation. | N/A | Yes |
| `percentile` | `integer` | The percentile to calculate (e.g., `95` for 95th percentile). | N/A | Yes |

**Percentile Rank (`aggregation: percentile_rank`)**

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `aggregation` | `Literal['percentile_rank']` | Determines the rank of a specific value within the dataset. | `percentile_rank` | Yes |
| `field` | `string` | The numeric field for percentile rank calculation. | N/A | Yes |
| `rank` | `integer` | The value for which to find the percentile rank. | N/A | Yes |

### Formula Metric

Allows custom calculations using Kibana's native formula syntax. Formulas enable complex calculations that combine multiple aggregations, field operations, and mathematical expressions.

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------- | ------------------------- | ------------------------------------------------ | ---------------- | -------- |
| `formula` | `string` | The formula string using Kibana formula syntax. | N/A | Yes |
| `label` | `string` | A custom display label for the metric. | `"Formula"` | No |
| `format` | `LensMetricFormatTypes` object | How to format the metric's value. | Default number format | No |

**Example Formulas:**

Simple arithmetic:

```yaml
primary:
  formula: "count() / 100"
  label: "Count Percentage"
```

Field aggregations:

```yaml
primary:
  formula: "max(response.time) - min(response.time)"
  label: "Response Time Range"
  format:
    type: duration
```

With filters:

```yaml
primary:
  formula: "count(kql='status:error') / count() * 100"
  label: "Error Rate %"
  format:
    type: percent
```

Number formatting:

```yaml
primary:
  formula: "average(bytes)"
  label: "Avg Bytes"
  format:
    type: bytes
    compact: true
```

---

## Metric Formatting (`format` field within a metric)

Defines how metric values are displayed in visualizations.

### Standard Format

::: dashboard_compiler.panels.charts.lens.metrics.config.LensMetricFormat
    options:
      show_root_heading: false
      heading_level: 4

**Default Decimal Places (Kibana):**

When no `pattern` is specified, Kibana applies these defaults:

* `number`: 2 decimal places
* `bytes`: 2 decimal places
* `bits`: 0 decimal places
* `percent`: 2 decimal places
* `duration`: 0 decimal places (uses smart duration formatting like "1m 30s")

### Custom Format

::: dashboard_compiler.panels.charts.lens.metrics.config.LensCustomMetricFormat
    options:
      show_root_heading: false
      heading_level: 4

---

## Pie Chart Specific Formatting

These objects are used within the `LensPieChart` configuration.

### Pie Chart Appearance (`appearance` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------------------- | ------------------------------------------------ | ---------------- | -------- |
| `donut` | `Literal['small', 'medium', 'large']` | If set, creates a donut chart with the specified hole size. | `None` (pie) | No |

### Pie Titles and Text (`titles_and_text` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `slice_labels` | `Literal['hide', 'inside', 'auto']` | How to display labels for each slice. | `auto` | No |
| `slice_values` | `Literal['hide', 'integer', 'percent']` | How to display the value for each slice. | `percent` | No |
| `value_decimal_places` | `integer` (0-10) | Number of decimal places for slice values. | `2` | No |

### Pie Legend (`legend` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `visible` | `Literal['show', 'hide', 'auto']` | Controls legend visibility. | `auto` | No |
| `width` | `Literal['small', 'medium', 'large', 'extra_large']` | Width of the legend area. | `medium` | No |
| `truncate_labels` | `integer` (0-5) | Max number of lines for legend labels before truncating. `0` disables truncation. | `1` | No |

### Color Mapping (`color` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------- | --------- | ------------------------------------------------ | ---------------- | -------- |
| `palette` | `string` | The ID of the color palette to use (e.g., `default`, `elasticColors`). | `default` | Yes |

## Related Documentation

* [Base Panel Configuration](base.md)
* [Dashboard Configuration](../dashboard/dashboard.md)
* [Queries Configuration](../queries/config.md)
* [Filters Configuration](../filters/config.md)


---
# Source: panels/esql.md
---

# ESQL Panel Configuration

ESQL panels leverage the power of Elasticsearch Query Language (ESQL) to create visualizations. This allows for more complex data transformations and aggregations directly within the query that feeds the chart.

The `ESQLPanel` is the primary container. Its `esql` field holds the ESQL query, and its `chart` field defines the specific type of visualization (e.g., `metric`, `pie`).

## A Poem for the Query Wizards

_For those who wield the power of Elasticsearch Query Language:_

```text
FROM the indexes, data flows,
WHERE the data goes, nobody knows.
STATS works on numbers, ORDER shows the best,
LIMIT lets the engine rest.

ESQL queries, powerful and clean,
Transforming data never seen!
Complex aggregations, custom math,
Your query blazes the perfect path.

No need for pre-defined fields to bind,
You shape your metrics, well-defined.
FROM, BY, and STATS aligned,
Column names thoughtfully designed.

So here's to those who love to query,
With ESQL power, never weary!
Direct from Elasticsearch's core,
Your visualizations are never a bore!
```

---

## Minimal Configuration Examples

**Minimal ESQL Metric Chart:**

```yaml
dashboards:
  - name: "ESQL Metrics Dashboard"
    panels:
      - title: "Total Processed Events"
        size: {w: 16, h: 3}
        esql:
          type: metric
          query: |
            FROM logs-*
            | STATS total_events = COUNT(*)
          primary:
            field: "total_events"
```

!!! tip "Advanced: Query Reuse with YAML Anchors"
    ES|QL queries can also be defined as arrays, enabling reuse patterns with YAML anchors. This lets you define base queries once and extend them across multiple panels. See [ES|QL Query Reuse with YAML Anchors](../advanced/esql-views.md) for detailed patterns and examples.

**Minimal ESQL Pie Chart:**

```yaml
dashboards:
  - name: "ESQL Event Analysis"
    panels:
      - title: "Events by Type (ESQL)"
        size: {w: 32, h: 3}
        position: {x: 16, y: 0}
        esql:
          type: pie # Specifies an ESQLPieChart
          query: |
            FROM logs-*
            | STATS event_count = COUNT(*) BY event.category
            | ORDER event_count DESC
            | LIMIT 5
          metrics:
            - field: "event_count"
          dimensions:
            - field: "event.category"
```

## Full Configuration Options

### ESQL Panel (`type: charts` with an `esql` field)

This is the main object for an ESQL-based visualization. It inherits from the [Base Panel Configuration](base.md). The presence of the `esql` field distinguishes it from a Lens panel.

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ------------------------------- | -------- |
| `type` | `Literal['charts']` | Specifies the panel type. For ESQL panels, this is `charts`. | `charts` | Yes |
| `id` | `string` | A unique identifier for the panel. Inherited from BasePanel. | Generated ID | No |
| `title` | `string` | The title displayed on the panel header. Inherited from BasePanel. | `""` (empty string) | No |
| `hide_title` | `boolean` | If `true`, the panel title will be hidden. Inherited from BasePanel. | `false` | No |
| `description` | `string` | A brief description of the panel. Inherited from BasePanel. | `""` (empty string, if `None`) | No |
| `size` | `Size` object | Defines the panel's width and height. Inherited from BasePanel. See [Size Object Configuration](base.md#size-object-configuration-size). | `w: 12, h: 8` | No |
| `position` | `Position` object | Defines the panel's x/y coordinates. Inherited from BasePanel. See [Position Object Configuration](base.md#position-object-configuration-position). | Auto-calculated | No |
| `esql` | `ESQLChartConfig` object | Defines the actual ESQL visualization configuration. Contains the query, time_field, and chart type-specific fields. | N/A | Yes |

### ESQL Chart Configuration Fields

All ESQL chart types share these common panel-level fields:

| YAML Key | Data Type | Description | Default | Required |
| ----------- | -------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `query` | `string` or `ESQLQuery` object | The ESQL query string. See [Queries Documentation](../queries/config.md#esql-query). | N/A | Yes |
| `time_field` | `string` | The time field to use for the dashboard time picker. This connects the panel to the dashboard's global time range controls. | `'@timestamp'` | No |
| `type` | Chart type literal | The specific chart type (metric, pie, bar, line, area, etc.). See chart-specific sections below. | N/A | Yes |

**Example using custom time field:**

```yaml
dashboards:
  - name: "Custom Time Field Example"
    panels:
      - title: "Events Over Time"
        size: {w: 48, h: 20}
        esql:
          type: bar
          query: |
            FROM logs-*
            | STATS event_count = COUNT(*) BY timestamp_bucket = BUCKET(event.created, 1 hour)
            | ORDER timestamp_bucket ASC
          time_field: "event.created"  # Use event.created instead of @timestamp
          dimension:
            field: "timestamp_bucket"
          metrics:
            - field: "event_count"
```

---

## ESQL Metric Chart (`chart.type: metric`)

Displays a single primary metric derived from an ESQL query, optionally with a secondary metric, a maximum value, and a breakdown dimension. The `field` names in the chart configuration **must** correspond to column names produced by the ESQL query.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['metric']` | Specifies the chart type as an ESQL Metric visualization. | `metric` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `primary` | `ESQLMetric` object | The primary metric to display. Its `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | N/A | Yes |
| `secondary` | `ESQLMetric` object | An optional secondary metric. Its `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | `None` | No |
| `maximum` | `ESQLMetric` object | An optional maximum metric. Its `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | `None` | No |
| `breakdown` | `ESQLDimension` object | An optional dimension to break down the metric by. Its `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |

**Example (ESQL Metric Chart):**

```yaml
dashboards:
  - name: "ESQL Metric Example"
    description: "Example of ESQL metric panel with primary, secondary, and breakdown"
    panels:
      - title: "Service Performance Metrics"
        size: {w: 24, h: 15}
        esql:
          type: metric
          query: |
            FROM logs-*
            | STATS avg_response_time = AVG(response.time),
                    p95_response_time = PERCENTILE(response.time, 95.0) BY service_name
          primary:
            field: "avg_response_time"
          secondary:
            field: "p95_response_time"
          breakdown:
            field: "service_name"
```

---

## ESQL Pie Chart (`chart.type: pie`)

Visualizes proportions of categories using slices of a pie or a donut chart, with data sourced from an ESQL query. The `field` names in the chart configuration **must** correspond to column names produced by the ESQL query.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['pie']` | Specifies the chart type as an ESQL Pie visualization. | `pie` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `metrics` | `ESQLMetric \| list[ESQLMetric]` object | A single metric or list of metrics that determine the size of each slice. Each `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | N/A | Yes |
| `dimensions` | `list of ESQLDimension` objects | One or more dimensions that determine how the pie is sliced. Each `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | N/A | Yes |
| `appearance` | `PieChartAppearance` object | Formatting options for the chart appearance. See [Pie Chart Appearance](#pie-chart-appearance-formatting-appearance-field) (shared with Lens). | `None` | No |
| `titles_and_text` | `PieTitlesAndText` object | Formatting options for slice labels and values. See [Pie Titles and Text](#pie-titles-and-text-formatting-titles_and_text-field) (shared with Lens). | `None` | No |
| `legend` | `PieLegend` object | Formatting options for the chart legend. See [Pie Legend](#pie-legend-formatting-legend-field) (shared with Lens). | `None` | No |
| `color` | `ColorMapping` object | Formatting options for the chart color palette. See [Color Mapping](#color-mapping-formatting-color-field) (shared with Lens). | `None` | No |

**Example (ESQL Pie Chart):**

```yaml
dashboards:
  - name: "ESQL Pie Chart Example"
    description: "Example of ESQL pie chart with donut appearance"
    panels:
      - title: "Error Types Distribution"
        size: {w: 24, h: 15}
        esql:
          type: pie
          query: |
            FROM logs-*
            | STATS error_count = COUNT(error.code) BY error_type
            | ORDER error_count DESC
            | LIMIT 10
          metrics:
            - field: "error_count"
          dimensions:
            - field: "error_type"
          appearance:
            donut: "small"
```

---

## ESQL Bar Chart (`chart.type: bar`)

Displays bar chart visualizations with data sourced from an ESQL query. Supports stacked, unstacked, and percentage modes. The `field` names in the chart configuration **must** correspond to column names produced by the ESQL query.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['bar']` | Specifies the chart type as an ESQL Bar visualization. | `bar` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `mode` | `Literal['stacked', 'unstacked', 'percentage']` | Stacking mode for bar charts. | `'stacked'` | No |
| `dimension` | `ESQLDimension` object | A single dimension that determines the X-axis (0 or 1 dimension allowed). The `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `metrics` | `list of ESQLMetric` objects | One or more metrics that determine the Y-axis values. Each `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | N/A | Yes |
| `breakdown` | `ESQLDimension` object | An optional dimension to split the series by. Its `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `appearance` | `XYAppearance` object | Formatting options for chart appearance. See [XY Chart Appearance](#xy-chart-appearance-formatting-appearance-field). | `None` | No |
| `legend` | `XYLegend` object | Formatting options for the chart legend. See [XY Legend](#xy-legend-formatting-legend-field). | `None` | No |
| `color` | `ColorMapping` object | Formatting options for the chart color palette. See [Color Mapping](#color-mapping-formatting-color-field) (shared with other chart types). | `None` | No |

**Example (ESQL Bar Chart):**

```yaml
dashboards:
  - name: "ESQL Bar Chart Example"
    description: "Example of ESQL bar chart with stacked mode"
    panels:
      - title: "Events Over Time by Category"
        size: {w: 48, h: 20}
        esql:
          type: bar
          query: |
            FROM logs-*
            | STATS event_count = COUNT(*) BY timestamp_bucket = BUCKET(@timestamp, 1 hour), event.category
            | ORDER timestamp_bucket ASC
          mode: stacked
          dimension:
            field: "timestamp_bucket"
          metrics:
            - field: "event_count"
          breakdown:
            field: "event.category"
```

---

## ESQL Line Chart (`chart.type: line`)

Displays line chart visualizations with data sourced from an ESQL query. The `field` names in the chart configuration **must** correspond to column names produced by the ESQL query.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ---------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['line']` | Specifies the chart type as an ESQL Line visualization. | `line` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `dimension` | `ESQLDimension` object | A single dimension that determines the X-axis (0 or 1 dimension allowed). The `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `metrics` | `list of ESQLMetric` objects | One or more metrics that determine the Y-axis values. Each `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | N/A | Yes |
| `breakdown` | `ESQLDimension` object | An optional dimension to split the series by. Its `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `appearance` | `XYAppearance` object | Formatting options for chart appearance. See [XY Chart Appearance](#xy-chart-appearance-formatting-appearance-field). | `None` | No |
| `legend` | `XYLegend` object | Formatting options for the chart legend. See [XY Legend](#xy-legend-formatting-legend-field). | `None` | No |
| `color` | `ColorMapping` object | Formatting options for the chart color palette. See [Color Mapping](#color-mapping-formatting-color-field) (shared with other chart types). | `None` | No |

**Example (ESQL Line Chart):**

```yaml
dashboards:
  - name: "ESQL Line Chart Example"
    description: "Example of ESQL line chart with breakdown"
    panels:
      - title: "Average Response Time by Service"
        size: {w: 48, h: 20}
        esql:
          type: line
          query: |
            FROM logs-*
            | STATS avg_response_time = AVG(response.time) BY timestamp_bucket = BUCKET(@timestamp, 1 hour), service.name
            | ORDER timestamp_bucket ASC
          dimension:
            field: "timestamp_bucket"
          metrics:
            - field: "avg_response_time"
          breakdown:
            field: "service.name"
```

---

## ESQL Area Chart (`chart.type: area`)

Displays area chart visualizations with data sourced from an ESQL query. Supports stacked, unstacked, and percentage modes. The `field` names in the chart configuration **must** correspond to column names produced by the ESQL query.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['area']` | Specifies the chart type as an ESQL Area visualization. | `area` | Yes |
| `id` | `string` | An optional unique identifier for this specific chart layer. | Generated ID | No |
| `mode` | `Literal['stacked', 'unstacked', 'percentage']` | Stacking mode for area charts. | `'stacked'` | No |
| `dimension` | `ESQLDimension` object | A single dimension that determines the X-axis (0 or 1 dimension allowed). The `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `metrics` | `list of ESQLMetric` objects | One or more metrics that determine the Y-axis values. Each `field` refers to an ESQL result column. See [ESQL Metric Column](#esql-metric-column). | N/A | Yes |
| `breakdown` | `ESQLDimension` object | An optional dimension to split the series by. Its `field` refers to an ESQL result column. See [ESQL Dimension Column](#esql-dimension-column). | `None` | No |
| `appearance` | `XYAppearance` object | Formatting options for chart appearance. See [XY Chart Appearance](#xy-chart-appearance-formatting-appearance-field). | `None` | No |
| `legend` | `XYLegend` object | Formatting options for the chart legend. See [XY Legend](#xy-legend-formatting-legend-field). | `None` | No |
| `color` | `ColorMapping` object | Formatting options for the chart color palette. See [Color Mapping](#color-mapping-formatting-color-field) (shared with other chart types). | `None` | No |

**Example (ESQL Area Chart):**

```yaml
dashboards:
  - name: "ESQL Area Chart Example"
    description: "Example of ESQL area chart with stacked mode"
    panels:
      - title: "Total Bytes by Host"
        size: {w: 48, h: 20}
        esql:
          type: area
          query: |
            FROM logs-*
            | STATS bytes_total = SUM(bytes) BY timestamp_bucket = BUCKET(@timestamp, 1 hour), host.name
            | ORDER timestamp_bucket ASC
          mode: stacked
          dimension:
            field: "timestamp_bucket"
          metrics:
            - field: "bytes_total"
          breakdown:
            field: "host.name"
```

---

## ESQL Columns

For ESQL panels, the `primary`, `secondary`, `maximum` (in metric charts) and `metrics`, `dimensions` (in pie charts) fields refer to columns that **must be present in the output of your ESQL query**.

### ESQL Metric Column

Used to specify a metric column from your ESQL query result.

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | --------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `id` | `string` | An optional unique identifier for this metric column definition. | Generated ID | No |
| `field` | `string` | The name of the column in your ESQL query result that represents the metric value. | N/A | Yes |
| `label` | `string` | An optional display label for the metric. | `None` | No |
| `format` | `ESQLMetricFormat` object | Optional format configuration for the metric. See [ESQL Metric Format](#esql-metric-format). | `None` | No |

#### ESQL Metric Format

Configure how metric values are displayed (number format, suffix, decimal places, etc.).

**Standard Format Types:**

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | --------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['number', 'bytes', 'bits', 'percent', 'duration']` | The format type for the metric. | N/A | Yes |
| `decimals` | `integer` | Number of decimal places to display. If not specified, defaults to 2 for number/bytes/percent/duration, 0 for bits. | Type-dependent | No |
| `suffix` | `string` | Optional suffix to display after the number (e.g., 'KB', 'ms'). | `None` | No |
| `compact` | `boolean` | Whether to display the number in a compact format (e.g., '1.2K' instead of '1200'). | `None` | No |
| `pattern` | `string` | Optional Numeral.js pattern for custom formatting. Controls decimal places, thousands separators, and more (e.g., '0,0.00' for 2 decimals with comma separator, '0.0000' for 4 decimals). Note: `decimals` provides a simpler way to control decimal places without a pattern. | `None` | No |

**Custom Format Type:**

For completely custom number formatting, use:

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | --------- | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `type` | `Literal['custom']` | Indicates a custom format pattern. | `'custom'` | Yes |
| `pattern` | `string` | Numeral.js pattern for custom formatting (e.g., '0,0.[0000]', '0.00%'). | N/A | Yes |

**Example (Metric with Format):**

```yaml
dashboards:
  - name: "ESQL Metric Formatting Example"
    description: "Example showing various metric formatting options"
    panels:
      - title: "Formatted Metrics"
        size: {w: 48, h: 20}
        esql:
          type: bar
          query: |
            FROM logs-*
            | STATS total_bytes = SUM(bytes),
                    event_count = COUNT(*),
                    avg_response_time = AVG(response.time),
                    success_rate = COUNT(status == 200) / COUNT(*) * 100,
                    precise_value = AVG(bytes) BY timestamp_bucket = BUCKET(@timestamp, 1 hour)
            | ORDER timestamp_bucket ASC
          dimension:
            field: "timestamp_bucket"
          metrics:
            - field: "total_bytes"
              label: "Total Data"
              format:
                type: bytes
                decimals: 1
            - field: "event_count"
              label: "Events"
              format:
                type: number
                decimals: 0
            - field: "avg_response_time"
              label: "Avg Response Time"
              format:
                type: number
                decimals: 2
                suffix: "ms"
            - field: "success_rate"
              label: "Success Rate"
              format:
                type: percent
                decimals: 1
            - field: "precise_value"
              label: "Precise Value"
              format:
                type: number
                pattern: "0,0.0000"
```

### ESQL Dimension Column

Used to specify a dimension/grouping column from your ESQL query result.

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `id` | `string` | An optional unique identifier for this dimension column definition. | Generated ID | No |
| `field` | `string` | The name of the column in your ESQL query result that represents the dimension. | N/A | Yes |
| `data_type` | `Literal['date'] \| None` | The data type of the field. Set to `'date'` for time/date fields to enable proper sorting and formatting in Kibana. This is particularly useful when using `BUCKET()` to create time series. | `None` | No |
| `collapse` | `Literal['sum', 'avg', 'min', 'max'] \| None` | Aggregation function to apply when collapsing dimension values (e.g., for multi-value fields or breakdowns). | `None` | No |

**Example using data_type: date for time series:**

```yaml
dashboards:
  - name: "Time Series with BUCKET Example"
    panels:
      - title: "Events Over Time (Hourly Buckets)"
        size: {w: 48, h: 20}
        esql:
          type: bar
          query: |
            FROM logs-*
            | STATS event_count = COUNT(*) BY time_bucket = BUCKET(@timestamp, 1 hour)
            | ORDER time_bucket ASC
          dimension:
            field: "time_bucket"
            data_type: "date"  # Tells Kibana this is a date field for proper formatting
          metrics:
            - field: "event_count"
```

**When to use data_type: date:**

Use `data_type: 'date'` when your dimension field contains date/time values, especially when using ES|QL's `BUCKET()` function to create time series. This ensures:

- Proper date formatting in tooltips and axis labels
- Correct chronological sorting
- Time-based zoom and pan interactions
- Dashboard time picker integration (via `time_field`)

---

## Pie Chart Specific Formatting (Shared with Lens)

ESQL Pie Charts share the same formatting options for appearance, titles/text, legend, and colors as Lens Pie Charts.

### Pie Chart Appearance Formatting (`appearance` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------------------- | ------------------------------------------------ | ---------------- | -------- |
| `donut` | `Literal['small', 'medium', 'large']` | If set, creates a donut chart with the specified hole size. If not specified, Kibana displays as a pie chart (no donut hole). | `None` | No |

### Pie Titles and Text Formatting (`titles_and_text` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `slice_labels` | `Literal['hide', 'inside', 'auto']` | How to display labels for each slice. | `None` | No |
| `slice_values` | `Literal['hide', 'integer', 'percent']` | How to display the value for each slice. | `None` | No |
| `value_decimal_places` | `integer` (0-10) | Number of decimal places for slice values. | `None` | No |

### Pie Legend Formatting (`legend` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- | ---------------- | -------- |
| `visible` | `Literal['show', 'hide', 'auto']` | Controls legend visibility. | `None` | No |
| `width` | `Literal['small', 'medium', 'large', 'extra_large']` | Width of the legend area. | `None` | No |
| `truncate_labels` | `integer` (0-5) | Max number of lines for legend labels before truncating. `0` disables truncation. | `None` | No |

### Color Mapping Formatting (`color` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| --------- | --------- | ------------------------------------------------ | ---------------- | -------- |
| `palette` | `string` | The ID of the color palette to use (e.g., `default`, `elasticColors`). | `default` | Yes |

---

## XY Chart Specific Formatting (Shared with Lens)

ESQL XY Charts (bar, line, area) share the same formatting options for appearance and legend as Lens XY Charts.

### XY Chart Appearance Formatting (`appearance` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | ------------------------ | -------------------------------------------------------- | ------- | -------- |
| `x_axis` | `AxisConfig \| None` | Configuration for the X-axis (horizontal axis). | `None` | No |
| `y_left_axis` | `AxisConfig \| None` | Configuration for the left Y-axis (primary vertical axis). | `None` | No |
| `y_right_axis` | `AxisConfig \| None` | Configuration for the right Y-axis (secondary vertical axis). | `None` | No |
| `series` | `list[XYSeries] \| None` | Per-series visual configuration (axis assignment, colors). | `None` | No |

#### AxisConfig Options

| YAML Key | Data Type | Description | Kibana Default | Required |
| -------- | ------------------------------------------------ | ---------------------------------------------- | ------- | -------- |
| `title` | `str \| None` | Custom title for the axis. | `None` | No |
| `scale` | `Literal['linear', 'log', 'sqrt', 'time'] \| None` | Scale type for the axis. | `None` | No |
| `extent` | `AxisExtent \| None` | Axis bounds/range configuration. | `None` | No |

#### AxisExtent Options

| YAML Key | Data Type | Description | Kibana Default | Required |
| ------------- | -------------------------------------------- | --------------------------------------------------------- | ------- | -------- |
| `mode` | `Literal['full', 'data_bounds', 'custom']` | Extent mode: 'full' (entire range), 'data_bounds' (fit to data), 'custom' (manual bounds). | N/A | Yes |
| `min` | `float \| None` | Minimum bound (required when mode is 'custom'). | `None` | Conditional |
| `max` | `float \| None` | Maximum bound (required when mode is 'custom'). | `None` | Conditional |
| `enforce` | `bool \| None` | Whether to enforce the bounds strictly. | `None` | No |
| `nice_values` | `bool \| None` | Whether to round bounds to nice values. | `None` | No |

#### XYSeries Options

| YAML Key | Data Type | Description | Kibana Default | Required |
| ----------- | ------------------------------------------------- | ------------------------------------------------------------ | ------- | -------- |
| `metric_id` | `str` | ID of the metric this series configuration applies to. | N/A | Yes |
| `axis` | `Literal['left', 'right'] \| None` | Which Y-axis this series is assigned to (for dual-axis charts). | `None` | No |
| `color` | `str \| None` | Hex color code for the series (e.g., '#2196F3'). | `None` | No |

### XY Legend Formatting (`legend` field)

| YAML Key | Data Type | Description | Kibana Default | Required |
| ---------- | -------------------------------------------------------- | ------------------------------------------------- | ------- | -------- |
| `visible` | `bool \| None` | Whether the legend is visible. | `None` | No |
| `position` | `Literal['top', 'bottom', 'left', 'right'] \| None` | Position of the legend (Kibana defaults to 'right'). | `None` | No |

---

## Related Documentation

- [Base Panel Configuration](base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)
- [Queries Configuration](../queries/config.md#esql-query)
- Elasticsearch ESQL Reference (external)


---
# Source: panels/datatable.md
---

# Datatable Chart Panel Configuration

The Datatable chart panel displays tabular data with customizable columns, sorting, pagination, and formatting options. Perfect for displaying detailed records and performing quick data analysis.

## A Poem for the Spreadsheet Scholars

_For those who know that sometimes you just need to see the rows:_

```text
When charts and graphs just won't suffice,
And visual flair must pay the price,
The datatable stands, precise and plain—
Row after row, your data's domain.

Sort ascending, descending too,
Filter down to just a few.
Columns wide or columns tight,
Pages of data that just feel right.

Metrics summed at bottom's end,
Summary rows, your data's friend.
From service names to error codes,
Each cell tells a tale until it folds.

Left-align text and right-align numbers,
No visual tricks, no chart encumbers.
Just pure data, clean and true—
A dream come true for someone like you.

So here's to rows and columns straight,
To tables that enumerate:
Sometimes the simplest view prevails,
When details matter, datatable never fails!
```

---

## Lens Datatable Charts

::: dashboard_compiler.panels.charts.datatable.config.LensDatatableChart
    options:
      show_root_heading: false
      heading_level: 3

## Column Configuration

::: dashboard_compiler.panels.charts.datatable.config.DatatableColumnConfig
    options:
      show_root_heading: false
      heading_level: 3

## Metric Column Configuration

::: dashboard_compiler.panels.charts.datatable.config.DatatableMetricColumnConfig
    options:
      show_root_heading: false
      heading_level: 3

## Datatable Appearance

::: dashboard_compiler.panels.charts.datatable.config.DatatableAppearance
    options:
      show_root_heading: false
      heading_level: 3

## Sorting Configuration

::: dashboard_compiler.panels.charts.datatable.config.DatatableSortingConfig
    options:
      show_root_heading: false
      heading_level: 3

## Pagination Configuration

::: dashboard_compiler.panels.charts.datatable.config.DatatablePagingConfig
    options:
      show_root_heading: false
      heading_level: 3

## ES|QL Datatable Charts

::: dashboard_compiler.panels.charts.datatable.config.ESQLDatatableChart
    options:
      show_root_heading: false
      heading_level: 3

## Related Documentation

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/gauge.md
---

# Gauge Chart Panel Configuration

The Gauge chart panel displays a single metric value with optional min/max ranges and goal indicators, typically used for KPIs and progress tracking toward targets or thresholds.

## A Poem for the Progress Trackers

_For those who measure how close we are to the goal:_

```text
Not just a number on the screen,
But progress toward a target seen.
A gauge that fills from left to right,
From zero darkness into light.

Where are we now? How far to go?
The gauge will always let you know.
From minimum to maximum range,
Watch the colored needle change.

A goal line drawn across the way—
"You're almost there!" the markers say.
Arc or bullet, circle or bar:
The gauge reveals just where you are.

CPU usage, quota met,
Performance targets? Not a sweat.
Not just data, but direction clear—
The gauge tracks progress throughout the year.
```

---

## Lens Gauge Charts

::: dashboard_compiler.panels.charts.gauge.config.LensGaugeChart
    options:
      show_root_heading: false
      heading_level: 3

## Gauge Appearance

::: dashboard_compiler.panels.charts.gauge.config.GaugeAppearance
    options:
      show_root_heading: false
      heading_level: 3

## ES|QL Gauge Charts

::: dashboard_compiler.panels.charts.gauge.config.ESQLGaugeChart
    options:
      show_root_heading: false
      heading_level: 3

## Related

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)
- [Metric Charts](./metric.md)


---
# Source: panels/heatmap.md
---

# Heatmap Chart Panel Configuration

The Heatmap chart panel displays data as a matrix where cell colors represent metric values, typically used for visualizing patterns across two categorical dimensions or time-based intensity analysis.

## A Poem for the Pattern Seekers

_For those who see the world in shades of meaning:_

```text
When numbers need a visual cue,
And gradients tell the story true,
The heatmap paints intensity—
From cold to hot, for all to see.

Two dimensions cross and meet,
Where X and Y each take a seat.
Time and category, side by side,
Color coding serves as guide.

Dark where values run down low,
Bright where metrics brightly glow.
Each cell a window, each shade a clue,
The heatmap shows what's hiding in your view.

From server loads to user trends,
On color scale the truth depends.
So here's to heatmaps, bold and bright,
That turn cold data into light!
```

---

## Minimal Configuration Example

```yaml
dashboards:
  - name: "Server Activity Dashboard"
    panels:
      - title: "Activity by Hour and Day"
        size: {w: 24, h: 15}
        lens:
          type: heatmap
          data_view: "logs-*"
          x_axis:
            field: "@timestamp"
            type: date_histogram
            label: "Hour of Day"
          y_axis:
            field: "host.name"
            type: values
            label: "Server"
          value:
            aggregation: count
            label: "Request Count"
```

## Grid and Legend Configuration Example

Customize the appearance of your heatmap with grid and legend options:

```yaml
dashboards:
  - name: "Customized Heatmap"
    panels:
      - title: "Response Time Heatmap"
        size: {w: 24, h: 15}
        lens:
          type: heatmap
          data_view: "logs-*"
          x_axis:
            field: "@timestamp"
            type: date_histogram
          y_axis:
            field: "service.name"
            type: values
          value:
            aggregation: average
            field: "response.time"
            format:
              type: duration
          grid_config:
            cells:
              show_labels: true
            x_axis:
              show_labels: true
              show_title: true
            y_axis:
              show_labels: true
              show_title: true
          legend:
            visible: show
            position: right
```

## One-Dimensional Heatmap Example

Create a 1D heatmap by omitting the Y-axis:

```yaml
dashboards:
  - name: "Hourly Traffic Pattern"
    panels:
      - title: "Traffic Intensity by Hour"
        size: {w: 48, h: 8}
        lens:
          type: heatmap
          data_view: "logs-*"
          x_axis:
            field: "@timestamp"
            type: date_histogram
            label: "Hour"
          value:
            aggregation: count
            label: "Events"
```

## Lens Heatmap Chart

::: dashboard_compiler.panels.charts.heatmap.config.LensHeatmapChart
    options:
      show_root_heading: false
      heading_level: 3

## ES|QL Heatmap Chart

::: dashboard_compiler.panels.charts.heatmap.config.ESQLHeatmapChart
    options:
      show_root_heading: false
      heading_level: 3

## Grid Configuration

Control the visibility of cell labels, axis labels, and titles:

::: dashboard_compiler.panels.charts.heatmap.config.HeatmapGridConfig
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.heatmap.config.HeatmapCellsConfig
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.heatmap.config.HeatmapAxisConfig
    options:
      show_root_heading: false
      heading_level: 3

## Legend Configuration

Configure the color legend for your heatmap:

::: dashboard_compiler.panels.charts.heatmap.config.HeatmapLegendConfig
    options:
      show_root_heading: false
      heading_level: 3

## Related Documentation

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)
- [Legend Configuration Guide](../advanced/legend-configuration.md)
- [Heatmap Examples](../examples/heatmap-examples.yaml)


---
# Source: panels/metric.md
---

# Metric Chart Panel Configuration

The Metric chart panel displays a single value or a small set of key metrics, often used for KPIs or summary statistics.

## A Poem for the Dashboard Architects

_For those who distill chaos into a single number:_

```text
One number to rule them all,
One metric standing proud and tall.
From millions of logs, a truth extracted,
A KPI that comes perfectly compacted.

When executives ask "How are we doing?"
Your metric chart stops their stewing.
No need for graphs or tables wide,
Just one big number, full of pride.

Primary, secondary, maximum too,
These metrics tell the story true.
COUNT the users, SUM the sales,
AVERAGE the latency before the system fails.

So here's to metrics, bold and bright,
That make our dashboards such a sight!
A single value, clear and clean,
The most important number ever seen!
```

---

## Minimal Configuration Example

```yaml
dashboards:
  - name: "KPI Dashboard"
    panels:
      - title: "Total Hosts"
        size: {w: 12, h: 2}
        lens:
          type: metric
          data_view: "metrics-*"
          primary:
            aggregation: unique_count
            field: resource.attributes.host.name
```

## Formula Metric Example

Formula metrics allow you to create custom calculations using Kibana's formula syntax:

```yaml
dashboards:
  - name: "Error Monitoring"
    panels:
      - title: "Error Rate"
        size: {w: 12, h: 2}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            formula: "count(kql='status:error') / count() * 100"
            label: "Error Rate %"
            format:
              type: percent
```

## Full Configuration Options

### Lens Metric Chart

| YAML Key | Data Type | Description | Default | Required |
| ----------- | -------------------------------- | ------------------------------------------------------------- | ---------- | -------- |
| `type` | `Literal['metric']` | Specifies the chart type as metric. | `'metric'` | No |
| `data_view` | `string` | The data view that determines the data for the metric chart. | N/A | Yes |
| `primary` | `LensMetricTypes` | The primary metric to display (main value). | N/A | Yes |
| `secondary` | `LensMetricTypes \| None` | Optional secondary metric to display alongside the primary. | `None` | No |
| `maximum` | `LensMetricTypes \| None` | Optional maximum metric for comparison or thresholds. | `None` | No |
| `breakdown` | `LensDimensionTypes \| None` | Optional breakdown dimension for splitting the metric. | `None` | No |
| `color` | `ColorMapping \| None` | Color palette mapping for the metric. See [Color Mapping Configuration](base.md#color-mapping-configuration). | `None` | No |

#### Lens Metric Types

The `primary`, `secondary`, and `maximum` fields accept these metric configurations:

| Metric Type | Description | Key Fields | Example Use Case |
| ----------- | ----------- | ---------- | ---------------- |
| **Count** | Count documents or unique values | `aggregation: 'count' \| 'unique_count'`, `field` (optional) | Count total requests or unique users |
| **Sum** | Sum numeric field values | `aggregation: 'sum'`, `field` | Total revenue or bytes transferred |
| **Aggregation** | Other aggregations (avg, min, max, median, etc.) | `aggregation`, `field` | Average response time or max CPU usage |
| **Last Value** | Most recent value of a field | `aggregation: 'last_value'`, `field` | Latest status or most recent reading |
| **Percentile** | Calculate percentile of values | `aggregation: 'percentile'`, `field`, `percentile` | 95th percentile latency |
| **Percentile Rank** | Calculate rank of a value | `aggregation: 'percentile_rank'`, `field`, `rank` | What % of requests are faster than 500ms |
| **Formula** | Custom calculation using Kibana formula syntax | `formula`, `label` (optional), `format` (optional) | `count(kql='status:error') / count() * 100` |
| **Static Value** | Fixed numeric value | `value`, `label` (optional) | Target threshold or goal value |

**Common Fields:**

All metric types except Static Value support:

- `label`: Custom display label
- `format`: Number formatting (see [Format Configuration Options](#format-configuration-options) for details)
- `filter`: KQL filter to apply before aggregation

**Additional Field Details:**

- **Count**: Optional `field` (for counting specific field values), optional `exclude_zeros` (exclude zero values from count)
- **Sum**: Required `field`, optional `exclude_zeros` (exclude zero values from sum)
- **Last Value**: Required `field`, optional `date_field` (determines sort order for finding the most recent value)

**Examples:**

```yaml
# Count metric
primary:
  aggregation: count
  label: "Total Requests"

# Average metric
primary:
  aggregation: average
  field: response_time_ms
  label: "Avg Response Time"
  format:
    type: duration

# Formula metric
primary:
  formula: "count(kql='status:error') / count() * 100"
  label: "Error Rate %"
  format:
    type: percent
```

### ESQL Metric Chart

| YAML Key | Data Type | Description | Default | Required |
| ----------- | -------------------------------- | ------------------------------------------------------------- | ---------- | -------- |
| `type` | `Literal['metric']` | Specifies the chart type as metric. | `'metric'` | No |
| `primary` | `ESQLMetricTypes` | The primary metric to display (main value). | N/A | Yes |
| `secondary` | `ESQLMetricTypes \| None` | Optional secondary metric to display alongside the primary. | `None` | No |
| `maximum` | `ESQLMetricTypes \| None` | Optional maximum metric for comparison or thresholds. | `None` | No |
| `breakdown` | `ESQLDimensionTypes \| None` | Optional breakdown dimension for splitting the metric. | `None` | No |
| `color` | `ColorMapping \| None` | Color palette mapping for the metric. See [Color Mapping Configuration](base.md#color-mapping-configuration). | `None` | No |

#### ESQL Metric Types

The `primary`, `secondary`, and `maximum` fields accept these metric configurations:

| Metric Type | Description | Key Fields | Example Use Case |
| ----------- | ----------- | ---------- | ---------------- |
| **ESQL Metric** | Reference a column from your ESQL query result | `field` | Any aggregated value from STATS clause |
| **Static Value** | Fixed numeric value | `value`, `label` (optional) | Target threshold or goal value |

**ESQL metrics** reference columns produced by your ESQL query. The `field` must match a column name in your query result.

**Example:**

```yaml
# ESQL metric referencing query result column
esql:
  type: metric
  query: |
    FROM logs-*
    | STATS
        total_requests = COUNT(*),
        avg_duration = AVG(event.duration),
        error_rate = COUNT(kql='event.outcome:failure') / COUNT(*) * 100
  primary:
    field: "total_requests"  # References column from STATS
  secondary:
    field: "avg_duration"    # References column from STATS
  maximum:
    field: "error_rate"      # References column from STATS
```

The ESQL query determines what metrics are available - each column in your STATS clause becomes a metric you can reference.

## Programmatic Usage (Python)

You can create Metric chart panels programmatically using Python:

### Count Metric Example

```python
from dashboard_compiler.panels.charts.config import (
    LensMetricPanelConfig,
    LensPanel,
)
from dashboard_compiler.panels.charts.lens.metrics.config import (
    LensCountAggregatedMetric,
)
from dashboard_compiler.panels.config import Position, Size

panel = LensPanel(
    title='Total Documents',
    position=Position(x=0, y=0),
    size=Size(w=24, h=15),
    lens=LensMetricPanelConfig(
        type='metric',
        data_view='logs-*',
        primary=LensCountAggregatedMetric(),
    ),
)
```

### Average Metric Example

```python
from dashboard_compiler.panels.charts.config import (
    LensMetricPanelConfig,
    LensPanel,
)
from dashboard_compiler.panels.charts.lens.metrics.config import (
    LensOtherAggregatedMetric,
)
from dashboard_compiler.panels.config import Position, Size

panel = LensPanel(
    title='Avg Response Time',
    position=Position(x=0, y=0),
    size=Size(w=24, h=15),
    lens=LensMetricPanelConfig(
        type='metric',
        data_view='logs-*',
        primary=LensOtherAggregatedMetric(aggregation='average', field='response_time'),
    ),
)
```

### Formula Metric Example

```python
from dashboard_compiler.panels.charts.config import (
    LensMetricPanelConfig,
    LensPanel,
)
from dashboard_compiler.panels.charts.lens.metrics.config import (
    LensFormulaMetric,
    LensMetricFormat,
)
from dashboard_compiler.panels.config import Position, Size

panel = LensPanel(
    title='Error Rate',
    position=Position(x=0, y=0),
    size=Size(w=24, h=15),
    lens=LensMetricPanelConfig(
        type='metric',
        data_view='logs-*',
        primary=LensFormulaMetric(
            formula="count(kql='status:error') / count() * 100",
            label='Error Rate %',
            format=LensMetricFormat(type='percent'),
        ),
    ),
)
```

## Number Formatting

Metric charts support various number formatting options to display values in a user-friendly way. You can add suffixes, use compact notation, or apply custom number patterns.

### Format Configuration Options

The `format` field accepts an object with the following properties:

| YAML Key | Data Type | Description | Default | Required |
| -------- | --------- | ----------- | ------- | -------- |
| `type` | `string` | Format type: `'number'`, `'bytes'`, `'bits'`, `'percent'`, `'duration'` | `'number'` | No |
| `suffix` | `string` | Custom text appended to the formatted value | `''` | No |
| `prefix` | `string` | Custom text prepended to the formatted value | `''` | No |
| `compact` | `boolean` | Enable compact notation (e.g., 1.2K instead of 1200) | `false` | No |
| `pattern` | `string` | Custom numeral.js format pattern (e.g., `'0,0.00'`) | `null` | No |

### Suffix Formatting

Add custom text after metric values to provide context:

```yaml
dashboards:
  - name: "Metrics with Suffixes"
    panels:
      - title: "Request Rate"
        size: {w: 12, h: 8}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            aggregation: count
            label: "Requests"
            format:
              type: number
              suffix: " req/sec"

      - title: "Active Users"
        size: {w: 12, h: 8}
        position: {x: 12, y: 0}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            aggregation: unique_count
            field: "user.id"
            label: "Users"
            format:
              type: number
              suffix: " users"
```

### Compact Notation

Use compact notation to display large numbers in a more readable format (e.g., 1.2K instead of 1200):

```yaml
dashboards:
  - name: "Compact Metrics"
    panels:
      - title: "Total Events (Compact)"
        size: {w: 12, h: 8}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            aggregation: count
            label: "Events"
            format:
              type: number
              compact: true  # Displays as 1.2M, 500K, etc.
```

### Custom Number Patterns

Apply custom formatting patterns using numeral.js syntax:

```yaml
dashboards:
  - name: "Formatted Metrics"
    panels:
      - title: "Revenue (Currency)"
        size: {w: 12, h: 8}
        lens:
          type: metric
          data_view: "sales-*"
          primary:
            aggregation: sum
            field: "transaction.amount"
            label: "Total Revenue"
            format:
              type: number
              pattern: "0,0.00"  # Comma separators, 2 decimals

      - title: "Success Rate"
        size: {w: 12, h: 8}
        position: {x: 12, y: 0}
        lens:
          type: metric
          data_view: "logs-*"
          primary:
            formula: "count(kql='status:success') / count() * 100"
            label: "Success Rate"
            format:
              type: number
              pattern: "0.0a"    # 1 decimal + suffix (K, M, etc.)
              suffix: "%"
```

### Combining Format Options

You can combine multiple formatting options for maximum flexibility:

```yaml
dashboards:
  - name: "Combined Formatting"
    panels:
      - title: "Bandwidth Usage"
        size: {w: 12, h: 8}
        lens:
          type: metric
          data_view: "network-*"
          primary:
            aggregation: sum
            field: "network.bytes"
            label: "Total Bandwidth"
            format:
              type: bytes       # Built-in bytes format
              compact: true     # Use compact notation (MB, GB)
              suffix: "/day"    # Add custom suffix
```

For more examples of metric formatting, see [metric-formatting-examples.yaml](../examples/metric-formatting-examples.yaml).

## Related

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)
- [Metric Formatting Examples](../examples/metric-formatting-examples.yaml)


---
# Source: panels/mosaic.md
---

# Mosaic Chart Panel Configuration

The Mosaic chart panel visualizes categorical data as proportional rectangles, showing category distributions at a glance. Mosaic charts support exactly one metric, one dimension, and an optional breakdown.

---

## Lens Mosaic Charts

::: dashboard_compiler.panels.charts.mosaic.config.LensMosaicChart
    options:
      show_root_heading: false
      heading_level: 3

## Mosaic Chart Legend

For comprehensive guidance on legend configuration, see the [Legend Configuration Guide](../advanced/legend-configuration.md).

::: dashboard_compiler.panels.charts.mosaic.config.MosaicLegend
    options:
      show_root_heading: false
      heading_level: 3

## Mosaic Chart Titles and Text

::: dashboard_compiler.panels.charts.mosaic.config.MosaicTitlesAndText
    options:
      show_root_heading: false
      heading_level: 3

## ES|QL Mosaic Charts

::: dashboard_compiler.panels.charts.mosaic.config.ESQLMosaicChart
    options:
      show_root_heading: false
      heading_level: 3

## Related

- [Pie Chart Configuration](./pie.md)
- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/pie.md
---

# Pie Chart Panel Configuration

The Pie chart panel visualizes data as a pie or donut chart, useful for showing proportions of a whole.

## A Poem for the Proportion Perfectionists

_For those who love a good slice of data:_

```text
They say you can't have it all—
Pie charts beg to differ, y'all!
Round and round the data goes,
Each slice sized by what it shows.

Who's got the biggest piece of pie?
Just look—it catches every eye.
Donut hole? Small, medium, large?
Pick your style; you're in charge.

"Inside" or "auto" for the labels,
"Percent" values—crisp and stable.
Legend positioned left or right,
Colors keeping categories bright.

From traffic sources to error types,
Status codes and payment stripes—
Your data served up, fresh and whole:
Every slice helps reach your goal!
```

---

## Lens Pie Charts

::: dashboard_compiler.panels.charts.pie.config.LensPieChart
    options:
      show_root_heading: false
      heading_level: 3

## Pie Chart Appearance

::: dashboard_compiler.panels.charts.pie.config.PieChartAppearance
    options:
      show_root_heading: false
      heading_level: 3

## Pie Chart Legend

For comprehensive guidance on legend configuration, see the [Legend Configuration Guide](../advanced/legend-configuration.md).

::: dashboard_compiler.panels.charts.pie.config.PieLegend
    options:
      show_root_heading: false
      heading_level: 3

## Pie Chart Titles and Text

::: dashboard_compiler.panels.charts.pie.config.PieTitlesAndText
    options:
      show_root_heading: false
      heading_level: 3

## ES|QL Pie Charts

::: dashboard_compiler.panels.charts.pie.config.ESQLPieChart
    options:
      show_root_heading: false
      heading_level: 3

## Related

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/tagcloud.md
---

# Tag Cloud Chart Panel Configuration

The Tag Cloud chart panel visualizes term frequency as a word cloud, where the size of each tag is proportional to its metric value. This is useful for showing the most common or significant terms in your data.

## A Poem for the Cloud Watchers

_For those who see meaning in the drift of words:_

```text
Up above the dashboard sky,
Word clouds float and drift on by.
Tags in sizes large and small—
The bigger the word, the higher the fall.

From eighteen points to seventy-two,
Font sizes speak the gospel true.
Horizontal, vertical, angles wide,
Orientations multiply!

Error messages like cumulus forms,
User agents weathering storms,
Kubernetes labels floating free,
Pod names adrift across the sea.

"single", "right angled", "multiple" ways
To orient your word displays.
So here's to those who like to see
Their data in words, big and free!
```

---

## Lens Tagcloud Charts

::: dashboard_compiler.panels.charts.tagcloud.config.LensTagcloudChart
    options:
      show_root_heading: false
      heading_level: 3

## ESQL Tagcloud Charts

::: dashboard_compiler.panels.charts.tagcloud.config.ESQLTagcloudChart
    options:
      show_root_heading: false
      heading_level: 3

## Tagcloud Appearance

::: dashboard_compiler.panels.charts.tagcloud.config.TagcloudAppearance
    options:
      show_root_heading: false
      heading_level: 3

### Orientation Options

::: dashboard_compiler.panels.charts.tagcloud.config.TagcloudOrientationEnum
    options:
      show_root_heading: false
      heading_level: 4

## Related

- [Base Panel Configuration](base.md)
- [Lens Panel Configuration](lens.md) (see sections on Dimensions and Metrics)
- [ESQL Panel Configuration](esql.md) (see section on ESQL Columns)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/xy.md
---

# XY Chart Panel Configuration

The XY chart panel creates line, bar, and area charts for time series and other data visualizations.

## A Poem for the Time Series Enthusiasts

_For those who see patterns across the timeline:_

```text
Lines that rise and bars that fall,
Area charts that show it all.
X-axis marching slowly through time,
Y-axis tracking every climb.

When incidents spike at 2 AM,
The XY chart says: "Here I am."
Stacked or unstacked, the choice is yours,
Percentage mode for ratio scores.

Dimensions set the horizontal stage,
Metrics show what happens, page by page.
Break it down by service, host, or zone—
No pattern ever goes unknown.

From request counts to error rates,
Your time series sits and waits.
So here's to charts, both line and bar,
That show exactly where things are.
```

---

## Lens Bar Charts

::: dashboard_compiler.panels.charts.xy.config.LensBarChart
    options:
      show_root_heading: false
      heading_level: 3

## Lens Line Charts

::: dashboard_compiler.panels.charts.xy.config.LensLineChart
    options:
      show_root_heading: false
      heading_level: 3

## Lens Area Charts

::: dashboard_compiler.panels.charts.xy.config.LensAreaChart
    options:
      show_root_heading: false
      heading_level: 3

## Chart Appearance Options

### Bar Chart Appearance

::: dashboard_compiler.panels.charts.xy.config.BarChartAppearance
    options:
      show_root_heading: false
      heading_level: 4

### Line Chart Appearance

::: dashboard_compiler.panels.charts.xy.config.LineChartAppearance
    options:
      show_root_heading: false
      heading_level: 4

### Area Chart Appearance

::: dashboard_compiler.panels.charts.xy.config.AreaChartAppearance
    options:
      show_root_heading: false
      heading_level: 4

## Axis Configuration

::: dashboard_compiler.panels.charts.xy.config.AxisConfig
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.xy.config.AxisExtent
    options:
      show_root_heading: false
      heading_level: 3

### Axis Customization Examples

Customize axis titles, bounds, and scale types to better represent your data:

#### Custom Axis Titles

```yaml
dashboards:
  - name: "Custom Axis Titles"
    panels:
      - title: "Request Latency Over Time"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "response.time"
              label: "Avg Latency"
          appearance:
            x_axis:
              title: "Time (UTC)"
            y_left_axis:
              title: "Response Time (milliseconds)"
```

#### Custom Axis Bounds

Set explicit minimum and maximum values for the Y-axis:

```yaml
dashboards:
  - name: "Custom Axis Bounds"
    panels:
      - title: "CPU Usage (0-100%)"
        size: {w: 24, h: 15}
        lens:
          type: area
          data_view: "metrics-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "system.cpu.usage"
              label: "CPU %"
          appearance:
            y_left_axis:
              title: "CPU Usage"
              extent:
                mode: custom
                min: 0
                max: 100
```

#### Logarithmic Scale

Use logarithmic scale for data with exponential growth:

```yaml
dashboards:
  - name: "Logarithmic Scale"
    panels:
      - title: "Event Count (Log Scale)"
        size: {w: 24, h: 15}
        lens:
          type: bar
          data_view: "logs-*"
          dimension:
            field: "service.name"
            type: values
          metrics:
            - aggregation: count
              label: "Event Count"
          appearance:
            y_left_axis:
              title: "Count (log scale)"
              scale: log
```

#### Data Bounds Mode

Automatically fit the axis to the actual data range:

```yaml
dashboards:
  - name: "Data Bounds Mode"
    panels:
      - title: "Response Time"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "response.time"
          appearance:
            y_left_axis:
              extent:
                mode: data_bounds  # Fit to actual data
```

#### Dual Axis Charts

Configure different scales for left and right Y-axes:

```yaml
dashboards:
  - name: "Dual Axis Chart"
    panels:
      - title: "Requests vs Response Time"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: count
              label: "Request Count"
              axis: left
            - aggregation: average
              field: "response.time"
              label: "Avg Response (ms)"
              axis: right
          appearance:
            y_left_axis:
              title: "Request Count"
              extent:
                mode: data_bounds
            y_right_axis:
              title: "Response Time (ms)"
              extent:
                mode: custom
                min: 0
                max: 1000
```

## Legend Configuration

For comprehensive guidance on legend configuration, see the [Legend Configuration Guide](../advanced/legend-configuration.md).

::: dashboard_compiler.panels.charts.xy.config.XYLegend
    options:
      show_root_heading: false
      heading_level: 3

## Reference Lines

Reference lines are implemented as separate layers in multi-layer panels. This allows you to combine data visualizations with threshold lines in a single chart.

::: dashboard_compiler.panels.charts.xy.config.LensReferenceLineLayer
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.xy.config.XYReferenceLine
    options:
      show_root_heading: false
      heading_level: 3

### Reference Line Examples

Reference lines help highlight important thresholds, targets, or limits in your charts. Below are comprehensive examples showing different styling options and use cases.

#### Basic Reference Line

Add a simple horizontal line to mark a threshold:

```yaml
dashboards:
  - name: "Basic Reference Line"
    panels:
      - title: "Response Time with SLA Threshold"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "response.time"
              label: "Avg Response Time"
          layers:
            - type: reference_line
              data_view: "logs-*"
              reference_lines:
                - value: 500
                  label: "SLA Limit (500ms)"
```

#### Styled Reference Lines

Customize line color, width, and style:

```yaml
dashboards:
  - name: "Styled Reference Lines"
    panels:
      - title: "CPU Usage with Multiple Thresholds"
        size: {w: 24, h: 15}
        lens:
          type: area
          data_view: "metrics-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "system.cpu.usage"
              label: "CPU %"
          layers:
            - type: reference_line
              data_view: "metrics-*"
              reference_lines:
                # Warning threshold (yellow, dashed)
                - value: 70
                  label: "Warning"
                  color: "#FFA500"
                  line_width: 2
                  line_style: dashed
                # Critical threshold (red, solid)
                - value: 90
                  label: "Critical"
                  color: "#BD271E"
                  line_width: 3
                  line_style: solid
                # Target (green, dotted)
                - value: 50
                  label: "Target"
                  color: "#00BF6F"
                  line_width: 2
                  line_style: dotted
```

#### Reference Lines with Fill

Fill the area above or below a reference line:

```yaml
dashboards:
  - name: "Reference Lines with Fill"
    panels:
      - title: "Error Rate with Acceptable Range"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - formula: "count(kql='log.level:error') / count() * 100"
              label: "Error Rate %"
          layers:
            - type: reference_line
              data_view: "logs-*"
              reference_lines:
                # Fill above this line in red (danger zone)
                - value: 5
                  label: "Max Acceptable Error Rate"
                  color: "#BD271E"
                  line_width: 2
                  fill: above
                # Fill below this line in green (safe zone)
                - value: 1
                  label: "Target Error Rate"
                  color: "#00BF6F"
                  line_width: 1
                  fill: below
```

#### Reference Lines with Icons

Add icons to reference lines for visual emphasis:

```yaml
dashboards:
  - name: "Reference Lines with Icons"
    panels:
      - title: "Memory Usage with Limits"
        size: {w: 24, h: 15}
        lens:
          type: area
          data_view: "metrics-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: max
              field: "system.memory.used.pct"
              label: "Memory Usage %"
          layers:
            - type: reference_line
              data_view: "metrics-*"
              reference_lines:
                - value: 80
                  label: "Warning Level"
                  color: "#FFA500"
                  line_width: 2
                  icon: "alert"
                  icon_position: right
                - value: 95
                  label: "Critical Level"
                  color: "#BD271E"
                  line_width: 3
                  icon: "error"
                  icon_position: right
```

#### Multiple Metrics with Reference Lines

Combine multiple data series with reference lines:

```yaml
dashboards:
  - name: "Multi-Metric with Thresholds"
    panels:
      - title: "Request Metrics with SLA"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: average
              field: "response.time"
              label: "Avg Response Time"
              axis: left
            - aggregation: percentile
              field: "response.time"
              percentile: 95
              label: "P95 Response Time"
              axis: left
          layers:
            - type: reference_line
              data_view: "logs-*"
              reference_lines:
                - value: 500
                  label: "SLA: Avg < 500ms"
                  color: "#0077CC"
                  line_width: 2
                  line_style: solid
                  axis: left
                - value: 1000
                  label: "SLA: P95 < 1000ms"
                  color: "#9170B8"
                  line_width: 2
                  line_style: dashed
                  axis: left
```

#### Dynamic Reference Lines (Formula-Based)

While reference lines are typically static values, you can use formulas in your metrics to create threshold-aware visualizations:

```yaml
dashboards:
  - name: "Threshold-Aware Visualization"
    panels:
      - title: "Requests Above Threshold"
        size: {w: 24, h: 15}
        lens:
          type: bar
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          metrics:
            - aggregation: count
              label: "Total Requests"
            - formula: "count() - 1000"
              label: "Requests Above Threshold (1000)"
          layers:
            - type: reference_line
              data_view: "logs-*"
              reference_lines:
                - value: 1000
                  label: "Threshold"
                  color: "#BD271E"
                  line_width: 2
```

### Reference Line Best Practices

1. **Use Semantic Colors**: Match colors to meaning (green = good, yellow = warning, red = critical)
2. **Limit the Number**: Too many reference lines create visual clutter (3-4 maximum recommended)
3. **Clear Labels**: Always label reference lines so users understand what they represent
4. **Appropriate Fill**: Use fill sparingly and only when it adds clarity
5. **Consistent Styling**: Use the same styling patterns across dashboards for similar thresholds

## ES|QL XY Charts

::: dashboard_compiler.panels.charts.xy.config.ESQLBarChart
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.xy.config.ESQLLineChart
    options:
      show_root_heading: false
      heading_level: 3

::: dashboard_compiler.panels.charts.xy.config.ESQLAreaChart
    options:
      show_root_heading: false
      heading_level: 3

## Related

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/image.md
---

# Image Panel Configuration

The `image` panel type is used to display an image directly on your dashboard. This can be useful for branding, diagrams, or other visual elements.

## A Poem for the Visual Storytellers

_For those who know a picture is worth a thousand metrics:_

```text
When words and numbers just won't do,
A picture paints the broader view.
An SVG or PNG so fine
Can speak a thousand words in line.

Contain, cover, fill, or none—
Four ways to get the framing done.
Company logos, architecture maps,
System diagrams filling gaps.

From branding bold at dashboard's crown,
To network maps when things break down,
Your from_url pulls it through—
Background colors, alt text too.

So here's to images on the page,
Worth more than data can engage.
A visual anchor, tried and true,
That shows what numbers never knew.
```

---

## Image Panel

::: dashboard_compiler.panels.images.config.ImagePanel
    options:
      show_root_heading: false
      heading_level: 2

## Image Panel Configuration

::: dashboard_compiler.panels.images.config.ImagePanelConfig
    options:
      show_root_heading: false
      heading_level: 3

## Related Documentation

- [Base Panel Configuration](./base.md)
- [Dashboard Configuration](../dashboard/dashboard.md)


---
# Source: panels/search.md
---

# Search Panel Configuration

The `search` panel type is used to embed the results of a pre-existing, saved Kibana search directly onto your dashboard. This allows you to display dynamic log views, event lists, or any other data set defined by a saved search in Discover.

## A Poem for the Log Detectives

_For those who hunt through haystacks for needles:_

```text
The case runs hot. The logs are cold.
But Discover's got the clues on hold.
Embedded here upon your board—
No need to leave; it's all aboard.

Security breaches? Last night's crime?
System errors frozen in time?
Columns lined up, suspects neat,
Each row of evidence, complete.

saved_search_id—that's your lead,
The only clue you'll ever need.
Filters applied, the query's set,
The perp's in there. I'd place a bet.

From error logs to audit trails,
This search panel never fails.
Dynamic views that auto-scroll—
The log detective's on patrol.
```

---

## Search Panel

::: dashboard_compiler.panels.search.config.SearchPanel
    options:
      show_root_heading: false
      heading_level: 2

## Search Panel Configuration

::: dashboard_compiler.panels.search.config.SearchPanelConfig
    options:
      show_root_heading: false
      heading_level: 3

**Note on Behavior:** The appearance, columns displayed, sort order, and underlying query of the Search panel are primarily controlled by the configuration of the saved search itself within Kibana's Discover application. The dashboard panel configuration mainly serves to embed that saved search.

## Related Documentation

* [Base Panel Configuration](./base.md)
* [Dashboard Configuration](../dashboard/dashboard.md)
* Kibana Discover and Saved Searches documentation (external to this project).


---
# Source: controls/config.md
---

# Controls Configuration

Controls are interactive elements that can be added to a dashboard, allowing users to filter data or adjust visualization settings dynamically. They are defined as a list of control objects within each dashboard's `controls` field in the `dashboards:` array. Global behavior of controls can be managed via the `settings.controls` object.

## Minimal Configuration Examples

Here's a minimal example of an `options` list control:

```yaml
dashboards:
  - name: "Example Dashboard"
    controls:
      - type: options
        label: "Filter by OS Type"
        data_view: "metrics-*"
        field: "resource.attributes.os.type"
```

Here's a minimal example of a `range` slider control:

```yaml
dashboards:
  - name: "Example Dashboard"
    controls:
      - type: range
        label: "CPU Load Average (1m)"
        data_view: "metrics-*"
        field: "metrics.system.cpu.load_average.1m"
```

## Complex Configuration Example

This example demonstrates multiple controls with custom widths and global control settings:

```yaml
dashboards:
  - name: "Application Monitoring Dashboard"
    description: "Dashboard with interactive controls."
    settings:
      controls:
        label_position: "above"
        chain_controls: true
        click_to_apply: false
    controls:
      - type: options
        label: "Host Name"
        width: "medium"
        data_view: "metrics-*"
        field: "resource.attributes.host.name"
        multiple: true
        match_technique: "contains"
      - type: range
        label: "CPU Utilization"
        width: "large"
        data_view: "metrics-*"
        field: "metrics.system.cpu.utilization"
        step: 0.01
      - type: time
        label: "Custom Time Slice"
        width: "small"
        start_offset: 0.1  # 10% from the start of the global time range
        end_offset: 0.9    # 90% from the start of the global time range
```

## Full Configuration Options

### Control Settings (`settings.controls`)

Global settings for all controls on the dashboard. These are configured under the `settings.controls` path in your main dashboard YAML.

::: dashboard_compiler.controls.config.ControlSettings
    options:
      show_root_heading: false
      heading_level: 4

### Options List Control

Allows users to select one or more values from a list to filter data.

::: dashboard_compiler.controls.config.OptionsListControl
    options:
      show_root_heading: false
      heading_level: 4

#### Match Technique Options

::: dashboard_compiler.controls.config.MatchTechnique
    options:
      show_root_heading: false
      heading_level: 5

### Range Slider Control

Allows users to select a range of numeric values to filter data.

::: dashboard_compiler.controls.config.RangeSliderControl
    options:
      show_root_heading: false
      heading_level: 4

### Time Slider Control

Allows users to select a sub-section of the dashboard's current time range. This control does not use a `data_view` or `field` as it operates on the global time context.

::: dashboard_compiler.controls.config.TimeSliderControl
    options:
      show_root_heading: false
      heading_level: 4

**Note on Time Slider Offsets:** The YAML configuration expects `start_offset` and `end_offset` as float values between 0.0 (0%) and 1.0 (100%). Kibana internally represents these as percentages from 0.0 to 100.0. If not provided, Kibana defaults to `0.0` for start and `100.0` for end.

### ES|QL Controls

ES|QL controls allow users to filter ES|QL visualizations via variables. There are two main types:

1. **ES|QL Field/Function Controls** - For field/function selection (FIELDS, FUNCTIONS variable types)
2. **ES|QL Value Controls** - For value selection (VALUES, MULTI_VALUES, TIME_LITERAL variable types)

#### ES|QL Field Control

For field selection in ES|QL visualizations. Only supports static values via `choices`.

::: dashboard_compiler.controls.config.ESQLFieldControl
    options:
      show_root_heading: false
      heading_level: 5

#### ES|QL Function Control

For function selection in ES|QL visualizations. Only supports static values via `choices`.

::: dashboard_compiler.controls.config.ESQLFunctionControl
    options:
      show_root_heading: false
      heading_level: 5

#### Field/Function Control Examples

```yaml
controls:
  # Field selection control
  - type: esql
    variable_name: selected_field
    variable_type: fields
    choices: ["@timestamp", "host.name", "message", "log.level"]
    label: Select Field
    default: "@timestamp"

  # Function selection control
  - type: esql
    variable_name: aggregate_fn
    variable_type: functions
    choices: ["COUNT", "AVG", "SUM", "MAX", "MIN"]
    label: Aggregate Function
    default: "COUNT"
```

**Using ES|QL Variables in Panels:**

ES|QL control variables can be referenced in ES|QL panel queries:

- **Value variables** (VALUES, MULTI_VALUES, TIME_LITERAL) use single `?` prefix: `?variable_name`
- **Field/function variables** (FIELDS, FUNCTIONS) use double `??` prefix: `??variable_name`

```yaml
panels:
  # Using value variable
  - title: Filtered Requests
    esql:
      type: metric
      query:
        - FROM logs-*
        - WHERE http.response.status_code == ?status_code
        - STATS total = COUNT(*)

  # Using field variable
  - title: Dynamic Field Display
    esql:
      type: table
      query:
        - FROM logs-*
        - KEEP ??selected_field
        - LIMIT 100
```

#### ES|QL Static Single-Select Control (DEPRECATED)

::: dashboard_compiler.controls.config.ESQLStaticSingleSelectControl
    options:
      show_root_heading: false
      heading_level: 5

#### Static Values Example

```yaml
controls:
  # Multi-select with explicit multiple property
  - type: esql
    variable_name: environment
    variable_type: values
    choices: ["production", "staging", "development"]
    label: Environment
    multiple: true
    default: ["production", "staging"]

  # Single-select with string default (auto-infers multiple: false)
  - type: esql
    variable_name: status
    variable_type: values
    choices: ["200", "404", "500"]
    label: HTTP Status
    default: "200"
```

#### ES|QL Static Multi-Select Control (DEPRECATED)

::: dashboard_compiler.controls.config.ESQLStaticMultiSelectControl
    options:
      show_root_heading: false
      heading_level: 5

#### ES|QL Query-Driven Single-Select Control (DEPRECATED)

::: dashboard_compiler.controls.config.ESQLQuerySingleSelectControl
    options:
      show_root_heading: false
      heading_level: 5

#### ES|QL Query-Driven Multi-Select Control (DEPRECATED)

::: dashboard_compiler.controls.config.ESQLQueryMultiSelectControl
    options:
      show_root_heading: false
      heading_level: 5

#### Query-Driven Example

```yaml
controls:
  # Query-driven single-select
  - type: esql
    variable_name: status_code
    variable_type: values
    query: FROM logs-* | STATS count BY http.response.status_code | KEEP http.response.status_code | LIMIT 20
    label: HTTP Status Code
    multiple: false

  # Query-driven multi-select
  - type: esql
    variable_name: host_names
    variable_type: values
    query: FROM logs-* | STATS count BY host.name | KEEP host.name
    label: Host Names
    multiple: true

  # Query-driven single-select with default value
  - type: esql
    variable_name: region
    variable_type: values
    query: FROM logs-* | STATS count BY cloud.region | KEEP cloud.region
    label: Cloud Region
    multiple: false
    default: us-east-1

  # Query-driven multi-select with default values
  - type: esql
    variable_name: services
    variable_type: values
    query: FROM logs-* | STATS count BY service.name | KEEP service.name
    label: Services
    multiple: true
    default: ["api-gateway", "auth-service"]
```

**Note**: Default values for query-driven controls are not validated against query results since the values are fetched dynamically at runtime.

**Important**: ES|QL control queries **must return exactly one column** containing the values to display in the control. Use `KEEP` to select only the field column after aggregation.

## ES|QL Variable Types

::: dashboard_compiler.controls.types.ESQLVariableType
    options:
      show_root_heading: false
      heading_level: 3

## Related Documentation

- [Dashboard Configuration](./../dashboard/dashboard.md)


---
# Source: filters/config.md
---

# Filters Configuration

Filters are used to narrow down the data displayed on a dashboard or within individual panels. They are defined as a list of filter objects, typically under the `filters` key of a `dashboard` object or a panel that supports filtering.

## Minimal Configuration Examples

**Exists Filter:** Check if the `error.message` field exists.

```yaml
filters:
  - exists: "error.message"
```

**Phrase Filter:** Find documents where `status.keyword` is exactly "active".

```yaml
filters:
  - field: "status.keyword"
    equals: "active"
```

**Phrases Filter (using `in` alias):** Find documents where `event.category` is "authentication" OR "network".

```yaml
filters:
  - field: "event.category"
    in: ["authentication", "network"]
```

**Range Filter:** Find documents where `response_time` is between 100 (inclusive) and 500 (exclusive).

```yaml
filters:
  - field: "response_time"
    gte: "100" # Values are typically strings, Kibana handles conversion
    lt: "500"
```

## Complex Configuration Example

This example demonstrates a combination of filter types, including logical junctions (`and`, `or`) and a modifier (`not`).

```yaml
filters:
  - alias: "Successful Logins from US or CA"
    and: # `and_filters` in Pydantic, `and` in YAML
      - field: "event.action"
        equals: "user_login"
      - field: "event.outcome"
        equals: "success"
      - or: # `or_filters` in Pydantic, `or` in YAML
          - field: "source.geo.country_iso_code"
            equals: "US"
          - field: "source.geo.country_iso_code"
            equals: "CA"
  - alias: "Exclude test users"
    not: # `not_filter` in Pydantic, `not` in YAML
      field: "user.name"
      in: ["test_user_01", "qa_bot"]
  - exists: "transaction.id"
    disabled: true # This filter is defined but currently disabled
  - dsl:
      query_string:
        query: "message:(*error* OR *exception*) AND NOT logger_name:debug"
```

## Full Configuration Options

### Exists Filter

Checks for the existence of a specific field.

::: dashboard_compiler.filters.config.ExistsFilter
    options:
      show_root_heading: false
      heading_level: 4

### Phrase Filter

Matches documents where a specific field contains an exact phrase.

::: dashboard_compiler.filters.config.PhraseFilter
    options:
      show_root_heading: false
      heading_level: 4

### Phrases Filter

Matches documents where a specific field contains one or more of the specified phrases.

::: dashboard_compiler.filters.config.PhrasesFilter
    options:
      show_root_heading: false
      heading_level: 4

### Range Filter

Matches documents where a numeric or date field falls within a specified range. At least one of `gte`, `lte`, `gt`, or `lt` must be provided.

::: dashboard_compiler.filters.config.RangeFilter
    options:
      show_root_heading: false
      heading_level: 4

### Custom Filter

Allows for defining a custom Elasticsearch Query DSL filter.

::: dashboard_compiler.filters.config.CustomFilter
    options:
      show_root_heading: false
      heading_level: 4

### Negate Filter (`not`)

Excludes documents that match the nested filter.

::: dashboard_compiler.filters.config.NegateFilter
    options:
      show_root_heading: false
      heading_level: 4

### And Filter (`and`)

Matches documents that satisfy ALL of the specified nested filters.

::: dashboard_compiler.filters.config.AndFilter
    options:
      show_root_heading: false
      heading_level: 4

### Or Filter (`or`)

Matches documents that satisfy AT LEAST ONE of the specified nested filters.

::: dashboard_compiler.filters.config.OrFilter
    options:
      show_root_heading: false
      heading_level: 4

## Related Documentation

* [Dashboard Configuration](../dashboard/dashboard.md)
* [Queries Configuration](../queries/config.md)


---
# Source: queries/config.md
---

# Queries Configuration

Queries are used to define the search criteria for retrieving data. They can be applied globally at the dashboard level or specifically to individual panels that support them. This compiler supports KQL (Kibana Query Language), Lucene, and ESQL (Elasticsearch Query Language).

## Minimal Configuration Examples

**KQL Query:**

```yaml
# Applied at the dashboard level
dashboards:
- # ...
  query:
    kql: 'response_code:200 AND "user.id": "test-user"'
```

**Lucene Query:**

```yaml
# Applied at the dashboard level
dashboards:
- # ...
  query:
    lucene: 'event.module:nginx AND event.dataset:nginx.access'
```

**ESQL Query (typically for specific panel types like ESQL-backed charts):**

```yaml
# Example within a panel configuration that supports ESQL
panels:
  - type: some_esql_panel # Hypothetical panel type
    # ... other panel config
    query: |
      FROM my_index
      | STATS RARE(clientip)
```

## Full Configuration Options

Queries are typically defined under a `query` key, either at the root of the `dashboard` object or within a specific panel's configuration. The structure of the `query` object determines the language.

### KQL Query

Filters documents using the Kibana Query Language (KQL). This is often the default query language in Kibana.

::: dashboard_compiler.queries.config.KqlQuery
    options:
      show_root_heading: false
      heading_level: 4

**Usage Example (Dashboard Level):**

```yaml
dashboards:
- # ...
  query:
    kql: 'event.action:"user_login" AND event.outcome:success'
```

### Lucene Query

Filters documents using the more expressive, but complex, Lucene query syntax.

::: dashboard_compiler.queries.config.LuceneQuery
    options:
      show_root_heading: false
      heading_level: 4

**Usage Example (Dashboard Level):**

```yaml
dashboards:
- # ...
  query:
    lucene: '(geo.src:"US" OR geo.src:"CA") AND tags:"production"'
```

### ESQL Query

Uses Elasticsearch Query Language (ESQL) for data retrieval and aggregation. ESQL queries are typically used by specific panel types that are designed to work with ESQL's tabular results (e.g., ESQL-driven charts or tables).

::: dashboard_compiler.queries.config.ESQLQuery
    options:
      show_root_heading: false
      heading_level: 4

**Usage Example (Panel Level - String Format):**

```yaml
panels:
  - type: esql_backed_chart
    title: "Top User Agents by Count"
    query: |
      FROM "web-logs-*"
      | STATS count = COUNT(user_agent.name) BY user_agent.name
      | SORT count DESC
      | LIMIT 10
```

**Usage Example (Panel Level - Array Format):**

```yaml
panels:
  - type: esql_backed_chart
    title: "Top User Agents by Count"
    query:
      - FROM "web-logs-*"
      - STATS count = COUNT(user_agent.name) BY user_agent.name
      - SORT count DESC
      - LIMIT 10
```

When using the array format, query parts are automatically joined with the ES|QL pipe operator (`|`). Nested arrays produced by YAML anchor expansion are automatically flattened before joining, allowing flexible composition of query components. This enables powerful query reuse patterns with YAML anchors.

!!! tip "Advanced: ES|QL Query Reuse with YAML Anchors"
    You can use YAML anchors (`&` and `*`) to create reusable ES|QL query components, reducing duplication when multiple panels query similar data. This pattern lets you define base queries, filters, or complete "view-like" abstractions once and reference them across panels. See [ES|QL Query Reuse with YAML Anchors](../advanced/esql-views.md) for detailed patterns and examples.

## Query Scope

* **Dashboard Level Query**: Defined under `dashboard.query`. This query is applied globally to all panels that do not explicitly override it or ignore global queries. KQL and Lucene are supported at this level.
* **Panel Level Query**: Defined under `panel.query` (for panels that support it, e.g., Lens panels, ESQL panels). This query is specific to the panel and is often combined with (or can override) the dashboard-level query, depending on the panel's behavior.
  * Lens panels typically use KQL for their panel-specific query.
  * ESQL-specific panels will use an ESQL query string.

## Related Documentation

* [Dashboard Configuration](../dashboard/dashboard.md)
* [Filters Configuration](../filters/config.md)
* [Panel Documentation (e.g., Lens, ESQL specific panels)](../panels/base.md)
* [ESQL Panel Configuration](../panels/esql.md)


---
# Source: llm-workflows/index.md
---

# LLM-Driven Workflows

This section provides comprehensive guides for using Large Language Models (LLMs) to work with Kibana dashboards and the kb-yaml-to-lens compiler.

## Overview

LLMs can assist with dashboard creation and conversion in several ways:

- **Converting existing dashboards** from Kibana JSON to YAML format
- **Generating new dashboards** from natural language descriptions
- **Following best practices** for dashboard design and layout
- **Accessing complete documentation** via llms.txt and llms-full.txt

## Workflows

### [Dashboard Decompiling Guide](../dashboard-decompiling-guide.md)

Convert existing Kibana dashboard JSON files into YAML format. This guide provides step-by-step instructions for using the `kb-dashboard disassemble` command and converting components to YAML.

**Key topics:**

- Disassembling dashboard JSON into components
- Component-by-component conversion strategies
- Common patterns and mappings
- Validation and testing

### [Dashboard Style Guide](../dashboard-style-guide.md)

Best practices for designing effective Kibana dashboards, based on analysis of 49 production dashboards across 37 Elastic integration packages.

**Key topics:**

- Standard layout hierarchy and grid system
- Panel sizing and positioning conventions
- Visualization type selection
- Navigation and organization patterns
- Color and formatting standards

### [ES|QL Language Reference](esql-language-reference.md)

Complete ES|QL syntax reference for creating dashboards with ES|QL queries. Helps avoid common mistakes like using SQL syntax instead of ES|QL.

**Key topics:**

- ES|QL vs SQL differences and common mistakes
- Source commands (FROM, ROW, SHOW, TS)
- Processing commands (WHERE, STATS, EVAL, KEEP, etc.)
- Aggregation and time series functions
- Dashboard query patterns for different chart types

## LLM Resources

### llms.txt

Curated navigation file with links to key documentation sections. Perfect for LLMs to understand the project structure and available resources.

**Access:** [llms.txt](../llms.txt)

### llms-full.txt

Complete concatenation of all project documentation in navigation order. Provides comprehensive context for LLM-based dashboard creation and conversion.

**Access:** [llms-full.txt](../llms-full.txt)

**Note:** Both files are auto-generated during documentation builds via the `generate_llms_txt.py` MkDocs hook.

## Additional Resources

- [Complete Examples](../examples/index.md) - Real-world YAML dashboard examples
- [CLI Reference](../CLI.md) - Full command-line documentation including `disassemble` command
- [Panel Types Documentation](../panels/base.md) - Detailed panel configuration reference


---
# Source: dashboard-decompiling-guide.md
---

# Dashboard Decompiling Guide: Converting Kibana JSON to YAML

This guide provides instructions for converting Kibana dashboard JSON files into YAML format for kb-yaml-to-lens. It is designed to be consumed by LLMs (Large Language Models) to perform conversions efficiently.

## Quick Reference

**Complete Documentation**: For full schema reference and examples, use [llms-full.txt](https://strawgate.com/kb-yaml-to-lens/llms-full.txt) which contains all project documentation.

**Workflow**: `kb-dashboard fetch` → `kb-dashboard disassemble` → Convert to YAML → `kb-dashboard compile` → Validate

## Fetching Dashboard from Kibana

Retrieve a dashboard directly from Kibana using a URL or ID:

```bash
# Using dashboard URL
kb-dashboard fetch "https://kibana.example.com/app/dashboards#/view/my-id" \
    --output dashboard.ndjson

# Using dashboard ID
kb-dashboard fetch my-dashboard-id --output dashboard.ndjson
```

**Input Types:**

The `fetch` command accepts two types of input:

1. **Dashboard URL** - Full Kibana dashboard URL (e.g., `https://kibana.example.com/app/dashboards#/view/my-id`)
2. **Dashboard ID** - Plain dashboard ID (e.g., `my-dashboard-id`)

**How it works:**

- If the input looks like a URL, the dashboard ID is extracted from the URL
- Otherwise, the input is treated as a plain dashboard ID

**Authentication Options:**

```bash
# API Key authentication (recommended)
kb-dashboard fetch my-dashboard-id --output dashboard.ndjson \
    --kibana-api-key "your-api-key"

# Username/password authentication
kb-dashboard fetch my-dashboard-id --output dashboard.ndjson \
    --kibana-username user --kibana-password pass

# Specific Kibana space
kb-dashboard fetch my-dashboard-id --output dashboard.ndjson \
    --kibana-space-id "my-space"
```

**Input Formats Supported:**

- **URL (standard):** `https://kibana.example.com/app/dashboards#/view/{id}`
- **URL (with space):** `https://kibana.example.com/s/{space}/app/dashboards#/view/{id}`
- **URL (with query params):** `https://kibana.example.com/app/dashboards#/view/{id}?_g=...`
- **Plain dashboard ID:** `my-dashboard-id` or `dashboard-123`

## Disassembly

Break dashboard JSON into components:

```bash
kb-dashboard disassemble dashboard.ndjson -o output_dir/
```

**Output Structure:**

```text
output_dir/
├── metadata.json       # Dashboard title, description, id
├── options.json        # Display options (margins, colors, etc.)
├── controls.json       # Dashboard controls (if present)
├── filters.json        # Dashboard-level filters (if present)
├── references.json     # Data view references
└── panels/             # Individual panel JSON files
    ├── 000_panel-1_lens.json
    ├── 001_panel-2_markdown.json
    └── ...
```

## Conversion Strategy

### Incremental Approach

Convert one panel at a time and validate after each addition:

1. Create minimal dashboard structure
2. Add first panel
3. Compile: `kb-dashboard compile`
4. Fix errors if any
5. Repeat for remaining panels

### Minimal YAML

Omit fields that match defaults. Common defaults:

**Dashboard Level:**

- `use_margins: true`
- `sync_colors: false`
- `sync_cursor: true`
- `sync_tooltips: false`
- `hide_panel_titles: false`

**Panel Level:**

- Legend: `show: true`, `position: right`
- Values: `show_values: false`
- Breakdown: `size: 5`

Reference the documentation in llms-full.txt for component-specific defaults.

## Component Mapping

### Dashboard Metadata

**Input (metadata.json):**

```json
{
  "id": "my-dashboard-id",
  "title": "System Metrics Overview",
  "description": "Dashboard showing system performance metrics"
}
```

**Output (YAML):**

```yaml
---
dashboards:
  - name: System Metrics Overview
    description: Dashboard showing system performance metrics
    panels: []  # Panels will be added incrementally
```

### Markdown Panels

**Input:**

```json
{
  "type": "markdown",
  "gridData": {"x": 0, "y": 0, "w": 48, "h": 3},
  "panelConfig": {
    "markdown": "# Title\n\nContent here"
  }
}
```

**Output:**

```yaml
- markdown:
    content: |
      # Title

      Content here
  size: {w: 48, h: 3}
```

### Lens Metric Panels

**Input:**

```json
{
  "type": "lens",
  "gridData": {"x": 0, "y": 3, "w": 24, "h": 15},
  "embeddableConfig": {
    "attributes": {
      "title": "Total Documents",
      "visualizationType": "lnsMetric",
      "state": {
        "datasourceStates": {
          "formBased": {
            "layers": {
              "layer1": {
                "columns": {
                  "col1": {
                    "operationType": "count",
                    "label": "Count"
                  }
                }
              }
            }
          }
        }
      },
      "references": [
        {
          "type": "index-pattern",
          "id": "logs-*",
          "name": "indexpattern-datasource-layer-layer1"
        }
      ]
    }
  }
}
```

**Output:**

```yaml
- title: Total Documents
  size: {w: 24, h: 15}
  position: {x: 0, y: 3}
  lens:
    type: metric
    data_view: logs-*
    primary:
      aggregation: count
```

### Lens Pie Charts

**Input:**

```json
{
  "type": "lens",
  "visualizationType": "lnsPie",
  "state": {
    "datasourceStates": {
      "formBased": {
        "layers": {
          "layer1": {
            "columns": {
              "col1": {
                "operationType": "terms",
                "sourceField": "status",
                "params": {"size": 5, "orderBy": {"type": "column", "columnId": "col2"}, "orderDirection": "desc"}
              },
              "col2": {
                "operationType": "count"
              }
            }
          }
        }
      }
    }
  }
}
```

**Output:**

```yaml
- title: Status Breakdown
  size: {w: 24, h: 15}
  position: {x: 24, y: 3}
  lens:
    type: pie
    data_view: logs-*
    dimensions:
      - field: status
        type: values
        size: 5
    metrics:
      - aggregation: count
```

### Dashboard Controls

**Input (controls.json):**

```json
{
  "panelsJSON": "[{\"type\":\"optionsListControl\",\"order\":0,\"width\":\"medium\",\"fieldName\":\"namespace\"}]",
  "controlStyle": "oneLine"
}
```

**Output:**

```yaml
controls:
  - type: options
    label: Namespace
    data_view: metrics-*
    field: namespace
```

Reference [Dashboard Controls](controls/config.md) for complete options.

### Dashboard Filters

**Input (filters.json):**

```json
[
  {
    "meta": {
      "type": "phrase",
      "key": "service.name",
      "params": {"query": "web-server"}
    }
  }
]
```

**Output:**
Reference [Filters & Queries](filters/config.md) for filter conversion.

## Panel Type Reference

| Kibana Type | YAML Type | Documentation |
| ----------- | -------------------------- | ---------------------------------------- |
| `lnsMetric` | `lens.type: metric` | [Metric Charts](panels/metric.md) |
| `lnsPie` | `lens.type: pie` | [Pie Charts](panels/pie.md) |
| `lnsXY` | `lens.type: line/bar/area` | [XY Charts](panels/xy.md) |
| `lnsGauge` | `lens.type: gauge` | [Gauge Charts](panels/gauge.md) |
| `lnsDatatable` | `lens.type: table` | [Datatable Charts](panels/datatable.md) |
| `markdown` | `markdown` | [Markdown Panels](panels/markdown.md) |
| `links` | `links` | [Links Panels](panels/links.md) |

For ES|QL-based panels, see [ES|QL Panels](panels/esql.md).

## Validation

### Compile

```bash
kb-dashboard compile --input-dir my-yaml/ --output-dir compiled/
```

### Compare Structure

Use the comparison helper script to quickly check panel counts and types:

```bash
scripts/compare_panel_counts.sh original.ndjson compiled/output.ndjson
```

### Verification Workflow (Round-Trip Testing)

For thorough validation, use this round-trip workflow to verify the compiled output matches the original:

1. **Compile YAML to JSON:**

   ```bash
   kb-dashboard compile --input-dir my-yaml/ --output-dir /tmp/compiled/
   ```

   **IMPORTANT:** Fix any compilation errors before proceeding. The YAML must compile successfully.

2. **Disassemble both original and compiled dashboards:**

   ```bash
   # Disassemble original
   kb-dashboard disassemble original.ndjson -o /tmp/original_disassembled/

   # Disassemble compiled
   kb-dashboard disassemble /tmp/compiled/output.ndjson -o /tmp/compiled_disassembled/
   ```

3. **Compare panel structures:**

   Use the comparison helper script to analyze differences:

   ```bash
   python3 scripts/compare_dashboards.py /tmp/original_disassembled /tmp/compiled_disassembled
   ```

   This will show panel counts, types, and identify any mismatches.

4. **Verify panel structure and configuration:**

   Use `jq` to compare specific panel configurations between original and compiled:

   ```bash
   # Compare specific panel JSON structures
   diff -u \
     <(jq '.embeddableConfig.attributes.state' /tmp/original_disassembled/panels/003_panel-4_lens.json) \
     <(jq '.embeddableConfig.attributes.state' /tmp/compiled_disassembled/panels/003_panel-4_lens.json)
   ```

   **What to verify for each panel type:**

   **XY Charts (line, bar, area):**
   - Chart type matches (`seriesType` in original → `type` in YAML)
   - Stacking mode preserved (if `yConfig[].axisMode: stacked` exists)
   - Legend configuration matches (`legend.isVisible`, `legend.position`)
   - Dimensions properly mapped (count columns by `isBucketed: true`)
   - Breakdown configurations match (field names, size parameters)

   **Datatables:**
   - All bucketed columns appear as row dimensions
   - Size parameters match for each dimension
   - Metric columns preserve aggregation functions

   **All Lens panels:**
   - Aggregation functions match (median, average, sum, etc.)
   - Field names are exact (including namespace prefixes)
   - Format settings preserved (percent, bytes, number, etc.)

**Understanding discrepancies:**

When comparing original and compiled dashboards, some differences are expected:

- ✅ **Expected (safe):** Panel IDs differ, minor query formatting, panel order variations
- ⚠️ **Needs investigation:** Panel count mismatch, visualization type changes, missing dimensions/metrics, field name differences

**Verification checklist:**

Before considering a conversion complete:

- [ ] YAML compiles without errors
- [ ] Panel counts match (or differences are documented)
- [ ] Panel types match (lens, visualization, links, markdown)
- [ ] Chart configurations preserved (type, stacking, legends)
- [ ] All dimensions and breakdowns accounted for
- [ ] Size parameters match original values
- [ ] Field names and aggregations verified

## Common Patterns

### Lens Operation Mapping

| Kibana Operation | YAML Aggregation | Notes |
| ---------------- | ------------------------ | --------------------------- |
| `count` | `aggregation: count` | Document count |
| `sum` | `aggregation: sum` | Sum of field values |
| `avg` | `aggregation: average` | Average of field values |
| `min` | `aggregation: min` | Minimum value |
| `max` | `aggregation: max` | Maximum value |
| `median` | `aggregation: median` | Median value |
| `percentile` | `aggregation: percentile` | Requires `percentile` param |
| `terms` | `type: values` | Used in breakdowns/slices |
| `date_histogram` | `type: date_histogram` | Time-based dimension |
| `range` | `type: range` | Range-based dimension |

### XY Chart Dimensions

**Input (Kibana lens state):**

```json
{
  "columns": {
    "col1": {
      "operationType": "date_histogram",
      "sourceField": "@timestamp",
      "params": {"interval": "auto"}
    },
    "col2": {
      "operationType": "avg",
      "sourceField": "system.cpu.total.norm.pct"
    }
  }
}
```

**Output:**

```yaml
lens:
  type: line
  data_view: metrics-*
  dimensions:
    - field: '@timestamp'
      type: date_histogram
  metrics:
    - field: system.cpu.total.norm.pct
      aggregation: average
```

### Multi-Dimension Breakdowns

**Input:**

```json
{
  "columns": {
    "col1": {"operationType": "date_histogram", "sourceField": "@timestamp"},
    "col2": {"operationType": "terms", "sourceField": "host.name"},
    "col3": {"operationType": "avg", "sourceField": "cpu.usage"}
  }
}
```

**Output:**

```yaml
lens:
  type: line
  data_view: metrics-*
  dimensions:
    - field: '@timestamp'
      type: date_histogram
  breakdown:
    - field: host.name
      type: values
  metrics:
    - field: cpu.usage
      aggregation: average
```

## Error Resolution

### Schema Validation Errors

```text
ValidationError: 'type' is a required property
```

**Solution:** Check required fields in panel type documentation. Each panel type has specific required fields.

### Type Errors

```text
TypeError: Expected string, got int
```

**Solution:** Verify field types match schema. Common issues:

- Numbers as strings: use `100` not `"100"`
- Booleans as strings: use `true` not `"true"`

### Unsupported Panel Types

```text
Error: Panel type 'vega' is not supported
```

**Solution:** See [supported panel types](panels/base.md). For unsupported panels, either:

- Create placeholder markdown panel
- Skip the panel and document it

### Reference Resolution

```text
Error: Data view reference 'logs-*' not found
```

**Solution:** Ensure data views exist in target Kibana instance or are defined in YAML.

## Complete Example

**Disassembled Panel (001_panel-2_lens.json):**

```json
{
  "type": "lens",
  "gridData": {"x": 0, "y": 3, "w": 24, "h": 15},
  "embeddableConfig": {
    "attributes": {
      "title": "Total Documents",
      "visualizationType": "lnsMetric",
      "state": {
        "datasourceStates": {
          "formBased": {
            "layers": {
              "layer1": {
                "columns": {
                  "col1": {"operationType": "count", "label": "Count"}
                }
              }
            }
          }
        }
      },
      "references": [{"type": "index-pattern", "id": "logs-*"}]
    }
  }
}
```

**Converted YAML:**

```yaml
---
dashboards:
  - name: Application Monitoring
    description: Real-time application metrics
    panels:
      - title: Total Documents
        size: {w: 24, h: 15}
        position: {x: 0, y: 3}
        lens:
          type: metric
          data_view: logs-*
          primary:
            aggregation: count
```

**Validation:**

```bash
kb-dashboard compile
# Success! 1 panel
```

## Additional Resources

- **Complete Documentation**: [llms-full.txt](https://strawgate.com/kb-yaml-to-lens/llms-full.txt)
- **Examples**: [Complete Examples](examples/index.md)
- **Aerospike Examples**: [Complex real-world dashboards](https://github.com/strawgate/kb-yaml-to-lens/tree/main/docs/content/examples/aerospike)
- **Panel Type Docs**: [Panel Types Overview](panels/base.md)
- **Controls**: [Dashboard Controls](controls/config.md)
- **Filters**: [Filters & Queries](filters/config.md)
- **Advanced Topics**: [ES|QL Views](advanced/esql-views.md), [Color Assignments](advanced/color-assignments.md)


---
# Source: dashboard-style-guide.md
---

# Kibana Dashboard Style Guide

**Based on:** Analysis of Elastic Integrations repository dashboards
**Last Updated:** 2026-01-09
**Version:** 2.0

---

## Introduction

This guide documents best practices for designing Kibana dashboards, derived from analysis of 49 production dashboards across 37 Elastic integration packages. Follow these conventions to create dashboards that are consistent, intuitive, and effective for dashboard creators using kb-yaml-to-lens, teams standardizing dashboard design, and anyone building Kibana dashboards for Elastic integrations.

### Key Principles

1. **Predictable Organization** - Users navigate any dashboard using the same mental model
2. **Visualization Clarity** - Choose chart types based on data characteristics, not aesthetics
3. **Progressive Disclosure** - Flow from overview to detail (metrics → charts → tables)
4. **Functional Minimalism** - Every panel serves a purpose; avoid decorative elements
5. **Consistent Conventions** - Follow patterns for naming, sizing, and positioning

---

## Dashboard Structure

### Standard Layout Hierarchy

All dashboards follow this top-to-bottom structure:

1. **Context Layer** - Navigation, title, description
2. **Summary Layer** - Key metrics and KPIs
3. **Analysis Layer** - Charts and visualizations
4. **Detail Layer** - Data tables for drill-down

### Grid Layout (48-Column System)

Kibana uses a 48-column grid with standard panel widths:

| Panel Type | Width (columns) | Use Case |
| ---------- | --------------- | -------- |
| Full-width markdown | 48 | Navigation, section headers |
| Single metric card | 8-12 | Individual KPIs |
| Small chart | 12-16 | Pie/donut charts |
| Medium chart | 24 | Half-width time series |
| Full chart | 48 | Primary time series, maps |
| Data table | 48 | Detail drill-down |

Arrange charts in horizontal rows of 2-3 panels for easy comparison.

---

## Naming Conventions

### Dashboard Titles

**Format:** `[Category PackageName] Specific Focus`

**Generic Examples:**

- `[Logs WebServer] Access and error logs`
- `[Metrics Application] Heap`
- `[Logs Firewall] Connection analysis`
- `[Security EmailGateway] Threat detection`

**Category Prefixes:**

- `[Logs ...]` - Log analysis dashboards
- `[Metrics ...]` - Performance/metric dashboards
- `[Traces ...]` - APM trace dashboards
- Package name without prefix - When it's the only dashboard type

### Panel Titles

**Guidelines:**

- Be concise and descriptive
- Avoid redundant prefixes like "Chart of" or "Graph of"
- Include the dimension when relevant (e.g., "by Time", "by Category")

**Effective Examples:**

- "Socket Syscalls Time Series"
- "Top 10 Malware Threats"
- "Browsers Breakdown"
- "Response Codes Over Time"

---

## Visualization Selection

### Decision Framework

| Data Characteristic | Visualization | Example Use Case |
| ------------------- | ------------- | ---------------- |
| Single KPI/Count | Metric Card | Total Requests, Active Users |
| Categorical Proportions | Pie/Donut Chart | File types, browsers, protocols |
| Categorical Ranking (short labels) | Vertical Bar Chart | Category comparison |
| Categorical Ranking (long labels) | Horizontal Bar Chart | Top users, top URLs, top regions |
| Time Series - Event counts | Stacked Area Chart | Events by type over time |
| Time Series - Discrete events | Stacked Bar Chart | HTTP status codes over time |
| Time Series - Continuous metrics | Line Chart | Memory usage, CPU utilization |
| Hierarchical Categories | Treemap | Event categories with subcategories |
| Bounded Metrics (0-100%) | Gauge Chart | Memory usage %, disk capacity % |
| Performance Percentiles | Heatmap | 95th percentile latency over time |
| Top N with Details | Data Table | Top 10 threats with counts |
| Recent Events/Logs | Data Table | Audit logs, access logs |
| Geographic Distribution | Map | Access by country, network sources |

---

## Visualization Guidelines

Complete configuration details are available in [Lens Panel Configuration](panels/lens.md).

### Metric Cards

**When to Use:** High-level KPIs, single counts, status breakdowns at dashboard top.

**Best Practices:** Use sparingly (0-4 typical, 78% use zero). Group horizontally, position before detailed visualizations. Modern dashboards prefer charts over standalone metrics.

### Pie and Donut Charts

**When to Use:** Proportional distribution, "Top N" breakdowns (file types, browser/OS, protocols, event categories).

**Best Practices:** Show top 5-10 categories as percentages, prefer donut over pie, width 12-16 columns.

### Time Series Charts (XY Charts)

**Area Charts** (Most Common):

- Event frequency over time, volume trends
- Stacking shows categorical breakdown while maintaining total volume
- Filled area indicates volume

**Line Charts:**

- Precise metric tracking, performance monitoring
- Memory usage, CPU metrics, latency
- Dual-axis for comparing different metric scales

**Bar Charts:**

- Discrete time-bucketed events
- HTTP responses, error counts
- Stacking shows status code or category distribution

**Best Practices:**

- Use automatic time interval binning
- Add legends on the right side
- Stack when showing categorical breakdowns
- Use 30-day moving averages for smoothing trends (performance dashboards)

### Data Tables

**When to Use:** Detail drill-down, "Top N" lists, searchable log/event details.

**Best Practices:** Position at bottom (~60% preference) or intermixed with charts (security/log dashboards). Use 10 rows/page, sort by count descending, 3-6 columns for summaries. Column layout: count/frequency + primary dimension + secondary dimensions (who, where, when).

### Bar Charts (Non-Time-Series)

**Horizontal:** Long labels (URLs, usernames, regions), percentile distributions, better text readability.

**Vertical:** Short category labels, standard comparisons, stacking more common.

### Maps

**Point-Based:** Plot IP addresses/coordinates, security context, user access patterns. Panel type: `map`. Usage: 30% of dashboards.

**Choropleth:** Country/region-level aggregations, administrative boundaries. Visualization type: `lnsChoropleth`. Color intensity represents metric values.

### Treemap Charts

**When to Use:** Hierarchical categorical data (firewall events, network protocols, file systems, security classification).

**Best Practices:** Show parent-child category structure with proportions at each level. Effective for network/security dashboards.

### Heatmap Charts

**When to Use:** Performance analysis, percentile tracking (95th/99th), latency distributions, multi-dimensional correlations.

**Best Practices:** Combine time with categorical dimension. Common for request duration, response sizes, query performance, API latency by region/endpoint.

### Gauge Charts

**When to Use:** Bounded metrics (0-100%), utilization/capacity indicators (memory, disk, connection pools, cache hit rate, thread pools).

**Best Practices:** Clear min/max bounds, visual arc indicator, position in summary layer, limit to 3-6 per dashboard.

---

## Dashboard Components

### Markdown Panels

**Purpose:** Navigation and context.

**Positioning:** Always at the top.

**When to Use:**

- Standard for multi-dashboard packages (3+ dashboards)
- Position at top-left (x: 0, y: 0)
- Typical width: 10-18 columns for navigation, 48 columns for section headers

**Content Types:**

1. **Navigation Links** (Most Common)
   - Links to related dashboards in the package
   - Table of contents for multi-dashboard sets
   - Header: "Navigation" or "Table of Contents"
   - Bulleted list of dashboard links

2. **Section Headers**
   - Visual separation between dashboard areas
   - Use sparingly

3. **Context Information**
   - Brief explanations when title isn't self-explanatory

Single-purpose dashboards may omit navigation, but multi-dashboard packages should consistently provide navigation links for discoverability.

### Links Panels

For packages with multiple dashboards, links panels provide an alternative to markdown navigation. Pattern observed in 16% of multi-dashboard packages. Position at top with standard 12-column width.

### Control Filters

**Usage Pattern:** Control filters ARE used in approximately 25% of Elastic integration dashboards when multi-dimensional filtering adds value.

**Common Types:**

- Options list (dropdown selections)
- Range slider (numeric/date ranges)
- Hierarchical controls (nested categories)

**Positioning:** Top of dashboard after navigation

**When to Use:**

- Multi-tenant scenarios (filter by host, service, user)
- Complex dashboards requiring dynamic filtering across multiple dimensions
- Security dashboards with varied analysis perspectives

**Alternative Filtering Approaches:**

- Time picker (global time range selection)
- Dashboard-level filters (data stream, package filters)
- Panel-level filters (specific to individual visualizations)

---

## Filters and Queries

### Global Dashboard Filters

**Standard Pattern:** Filter by dataset using KQL syntax.

Single dataset:

```yaml
filters:
  - equals: package.dataset_name
    field: data_stream.dataset
```

Multiple datasets:

```yaml
filters:
  - query: "data_stream.dataset: (webserver.access OR webserver.error)"
```

### Panel-Level Filters

**Common Patterns:** Event type/category filters, status code filters, field existence checks.

Example:

```yaml
filters:
  - equals: connection
    field: event.type
  - equals: bind
    field: auditd.data.syscall
  - query: "NOT auditd.data.addr: netlink"
```

### Query Language

**Standard:** Use KQL (Kibana Query Language) for consistency.

---

## Color and Styling

### Color Schemes

Use Kibana's default color palette. Avoid custom color overrides (use sparingly) and too many colors (limit to 5-10 categories).

### Legend Positioning

**Standard:** Right-side placement
**Exception:** Bottom placement when charts are narrow

### Number Formatting

| Data Type | Format | Example |
| --------- | ------ | ------- |
| Bytes | 2 decimal precision | 1.23 GB |
| Counts | Integer | 1,234 |
| Percentages | Display on pie/donut | 45.2% |
| Dates | ISO format | 2024-01-15T10:30:00Z |

---

## Dashboard Types and Patterns

### Security Dashboards

Heavy use of categorical breakdowns (pie/donut charts), focus on "Top N" patterns (threats, users, actions), data tables for audit trails, control filters for multi-tenant scenarios.

**Flow:** Navigation → Controls → Events over time → Event categories → Top users/actions → Audit log

### Performance Dashboards

Exclusive use of line charts for precision, dual-axis comparisons, moving averages for smoothing. No pie charts (metrics don't have categorical proportions).

**Flow:** Navigation → Control → CPU/Memory over time → GC activity/Thread count → Latency/Throughput

### Infrastructure Dashboards

Mix of metrics, time series, and categorical breakdowns. Geographic maps when relevant, browser/OS distribution analysis, error rate and status code tracking.

**Flow:** Navigation → Metrics → Geographic distribution → Requests over time → Status codes → Browser/OS → Top URLs table

### Dashboard Complexity Spectrum

| Complexity | Panels | Viz Types | Panel Mix | Use Cases |
| ---------- | ------ | --------- | --------- | --------- |
| **Simple** | 3-6 | 1-2 | 0-2 metrics, 2-4 charts, 0-1 tables | Specialized performance tracking, single-service monitoring |
| **Standard** | 7-12 | 3-4 | 2-4 metrics, 4-6 charts, 1-2 tables | General-purpose monitoring, package overviews |
| **Complex** | 13+ | 5-6 | 3-6 metrics, 7-12 charts, 2-4 tables, controls | Enterprise monitoring, multi-dimensional analysis, security operations |

**Complex dashboard considerations:** Use markdown sections to separate areas, group related visualizations, maintain logical vertical flow. Consider breaking into multiple dashboards if exceeding 20 panels.

---

## Time Configuration

### Time Range

**Default Ranges:**

- Infrastructure monitoring: 15 minutes
- Security dashboards: User-selected (flexible)
- Performance monitoring: 1 hour to 24 hours

Enable time range restoration as best practice.

### Time Synchronization

**Standard:** Enable cursor synchronization across time-series panels.

```yaml
sync_cursor: true
sync_tooltips: false
```

---

## Accessibility and Usability

### Panel Sizing

**Minimum Heights:**

- Metric cards: 8 grid units
- Charts: 12-15 grid units
- Tables: 15-20 grid units (allow for pagination)

### Panel Ordering

**Vertical Flow Best Practices:**

1. Navigation and context (top)
2. Controls (immediately after navigation, when used)
3. Key metrics (before detailed charts)
4. Primary visualizations (middle)
5. Detail tables (bottom preferred, intermixed when contextually relevant)

### Responsive Considerations

- Avoid panels narrower than 12 columns
- Test dashboard at different screen sizes
- Ensure tables have horizontal scroll when needed

---

## Examples and Templates

Reference the `compiler/inputs/` directory for complete dashboard examples demonstrating these patterns. Templates show navigation panels, metric cards, time series charts, categorical breakdowns, and detail tables in standard configurations.

---

## Checklist

**Structure & Layout:**

- [ ] Title: `[Category Package] Focus` format, description when needed
- [ ] Hierarchy: context → control → summary → analysis → detail
- [ ] Navigation at top (multi-dashboard packages), tables at bottom (preferred)
- [ ] Standard widths (12, 16, 24, 48 columns), min 12 columns, charts 12-15 grid units

**Visualizations:**

- [ ] Chart types match data characteristics (area for events, line for metrics, pie for proportions)
- [ ] Metric cards: 0-4 per dashboard, pie/donut: top 5-10 only
- [ ] Specialized: treemap (hierarchical), heatmap (percentiles), gauge (0-100%)

**Naming & Formatting:**

- [ ] Panel titles concise, no redundant prefixes, field labels human-readable
- [ ] Number formatting appropriate, legends positioned correctly

**Filters & Controls:**

- [ ] Global filter for `data_stream.dataset`, panel filters specific, KQL syntax consistent
- [ ] Controls used when multi-dimensional filtering adds value

**Configuration & Testing:**

- [ ] Time range appropriate, cursor sync enabled for time-series
- [ ] Tested at different time ranges, filters work, tables paginate (10 rows), no console errors

---

## Additional Resources

### Related Documentation

- [Dashboard Decompiling Guide](dashboard-decompiling-guide.md) - Converting Kibana JSON to YAML
- [Panel Types Documentation](panels/base.md) - Detailed panel configuration
- [Lens Panel Configuration](panels/lens.md) - Complete field descriptions and options
- [Controls Documentation](controls/config.md) - Dashboard control configuration
- [Filters Documentation](filters/config.md) - Filter and query configuration

### External Resources

- [Kibana Lens Documentation](https://www.elastic.co/docs/explore-analyze/visualize/lens)
- [Elastic Common Schema (ECS)](https://www.elastic.co/guide/en/ecs/current/index.html)
- [Kibana Query Language (KQL)](https://www.elastic.co/docs/explore-analyze/query-filter/languages/kql)
- [Elasticsearch Query Language (ESQL)](https://www.elastic.co/docs/reference/query-languages/esql)


---
# Source: llm-workflows/esql-language-reference.md
---

# ES|QL Language Reference for Dashboard Creation

This guide provides essential ES|QL (Elasticsearch Query Language) syntax for LLMs creating Kibana dashboards. ES|QL is a piped query language distinct from SQL.

## ES|QL vs SQL: Key Differences

ES|QL is **not** SQL. Common mistakes:

| SQL Syntax (Wrong) | ES|QL Syntax (Correct) |
| ------------------ | --------------------- |
| `SELECT * FROM logs` | `FROM logs-*` |
| `SELECT COUNT(*) FROM logs WHERE status = 200` | `FROM logs-* \| WHERE status == 200 \| STATS COUNT(*)` |
| `SELECT * FROM logs ORDER BY @timestamp DESC LIMIT 10` | `FROM logs-* \| SORT @timestamp DESC \| LIMIT 10` |
| `SELECT host, COUNT(*) FROM logs GROUP BY host` | `FROM logs-* \| STATS COUNT(*) BY host` |
| `SELECT AVG(response_time) AS avg_time FROM logs` | `FROM logs-* \| STATS avg_time = AVG(response_time)` |
| `SELECT * FROM logs WHERE message LIKE '%error%'` | `FROM logs-* \| WHERE message LIKE "*error*"` |

Key differences:

- **Piped syntax**: Commands flow left-to-right with `|` (pipe) operators
- **Equality**: Use `==` not `=` for comparison
- **No SELECT**: Use `KEEP` to select columns, or just aggregate directly
- **No GROUP BY clause**: Use `BY` within `STATS`
- **Wildcards**: Use `*` in patterns, not `%`
- **Index patterns**: FROM uses Elasticsearch index patterns (e.g., `logs-*`)

---

## Source Commands

Every ES|QL query starts with a source command:

### FROM

Retrieves data from Elasticsearch indices, data streams, or aliases.

```esql
FROM logs-*
FROM logs-*, metrics-*
FROM logs-* METADATA _id, _index
```

### ROW

Creates inline data for testing:

```esql
ROW x = 1, y = "test", z = null
```

### SHOW

Returns deployment metadata:

```esql
SHOW INFO
```

### TS (Time Series)

Optimized source command for time series data streams. Available in Elasticsearch 9.2+ (tech preview).

```esql
TS my_metrics
| WHERE @timestamp >= NOW() - 1 day
| STATS SUM(RATE(requests)) BY TBUCKET(1 hour), host
```

---

## Processing Commands

Processing commands transform data. Chain them with `|`:

### WHERE

Filters rows by condition:

```esql
FROM logs-*
| WHERE status == 200
| WHERE response_time > 1000
| WHERE host.name LIKE "prod-*"
| WHERE event.category IN ("authentication", "network")
```

### STATS

Aggregates data with optional grouping:

```esql
# Simple aggregation
FROM logs-*
| STATS total = COUNT(*)

# Grouped aggregation
FROM logs-*
| STATS count = COUNT(*) BY host.name

# Multiple aggregations
FROM logs-*
| STATS
    total = COUNT(*),
    avg_time = AVG(response_time),
    max_time = MAX(response_time)
  BY service.name

# Time bucketing
FROM logs-*
| STATS event_count = COUNT(*) BY time_bucket = BUCKET(@timestamp, 1 hour)
| SORT time_bucket ASC
```

### EVAL

Creates or modifies columns:

```esql
FROM logs-*
| EVAL response_time_ms = response_time * 1000
| EVAL status_category = CASE(
    status >= 500, "error",
    status >= 400, "client_error",
    status >= 300, "redirect",
    "success"
  )
| EVAL is_slow = response_time > 1000
```

### KEEP

Selects and orders columns:

```esql
FROM logs-*
| KEEP @timestamp, host.name, message
| KEEP @timestamp, host.*  # Wildcards supported
```

### DROP

Removes columns:

```esql
FROM logs-*
| DROP password, secret_key
```

### RENAME

Renames columns:

```esql
FROM logs-*
| RENAME old_name AS new_name
| RENAME host.name AS hostname, service.name AS service
```

### SORT

Orders results:

```esql
FROM logs-*
| SORT @timestamp DESC
| SORT status ASC, response_time DESC
| SORT host.name ASC NULLS LAST
```

### LIMIT

Restricts row count (default is 1000):

```esql
FROM logs-*
| LIMIT 100
```

### DISSECT

Extracts fields from strings using delimiter patterns:

```esql
FROM logs-*
| DISSECT message "%{method} %{path} HTTP/%{version}"
```

### GROK

Extracts fields using regex patterns:

```esql
FROM logs-*
| GROK message "%{IP:client_ip} - %{DATA:user}"
```

### MV_EXPAND

Expands multi-valued fields into separate rows:

```esql
FROM logs-*
| MV_EXPAND tags
```

### ENRICH

Adds data from enrichment policies:

```esql
FROM logs-*
| ENRICH ip_location_policy ON client.ip WITH city, country
```

### LOOKUP JOIN

Joins with a lookup index:

```esql
FROM logs-*
| LOOKUP JOIN user_lookup ON user.id
```

---

## Aggregation Functions

Use within STATS:

| Function | Description | Example |
| -------- | ----------- | ------- |
| `COUNT(*)` | Count all rows | `STATS total = COUNT(*)` |
| `COUNT(field)` | Count non-null values | `STATS errors = COUNT(error.code)` |
| `COUNT_DISTINCT(field)` | Unique value count | `STATS unique_users = COUNT_DISTINCT(user.id)` |
| `SUM(field)` | Sum numeric values | `STATS total_bytes = SUM(bytes)` |
| `AVG(field)` | Average value | `STATS avg_time = AVG(response_time)` |
| `MIN(field)` | Minimum value | `STATS min_time = MIN(response_time)` |
| `MAX(field)` | Maximum value | `STATS max_time = MAX(response_time)` |
| `MEDIAN(field)` | Median value | `STATS median_time = MEDIAN(response_time)` |
| `PERCENTILE(field, n)` | Nth percentile | `STATS p95 = PERCENTILE(response_time, 95.0)` |
| `STD_DEV(field)` | Standard deviation | `STATS stddev = STD_DEV(response_time)` |
| `VARIANCE(field)` | Variance | `STATS var = VARIANCE(response_time)` |
| `VALUES(field)` | All unique values | `STATS hosts = VALUES(host.name)` |
| `TOP(field, n, order)` | Top N values | `STATS top_hosts = TOP(host.name, 5, "desc")` |

---

## Time Series Functions

For use with the TS source command (Elasticsearch 9.2+):

| Function | Description | Example |
| -------- | ----------- | ------- |
| `RATE(field)` | Per-second rate of counter increase | `STATS SUM(RATE(requests))` |
| `IRATE(field)` | Instant rate (last two points) | `STATS SUM(IRATE(requests))` |
| `DELTA(field)` | Absolute change of gauge | `STATS SUM(DELTA(temperature))` |
| `IDELTA(field)` | Instant delta (last two points) | `STATS SUM(IDELTA(gauge))` |
| `INCREASE(field)` | Absolute increase of counter | `STATS SUM(INCREASE(total_bytes))` |
| `AVG_OVER_TIME(field)` | Average over time window | `STATS MAX(AVG_OVER_TIME(cpu))` |
| `MAX_OVER_TIME(field)` | Maximum over time window | `STATS MAX(MAX_OVER_TIME(memory))` |
| `MIN_OVER_TIME(field)` | Minimum over time window | `STATS MIN(MIN_OVER_TIME(latency))` |
| `SUM_OVER_TIME(field)` | Sum over time window | `STATS SUM(SUM_OVER_TIME(bytes))` |
| `COUNT_OVER_TIME(field)` | Count over time window | `STATS SUM(COUNT_OVER_TIME(events))` |
| `FIRST_OVER_TIME(field)` | Earliest value by timestamp | `STATS MAX(FIRST_OVER_TIME(value))` |
| `LAST_OVER_TIME(field)` | Latest value by timestamp | `STATS MAX(LAST_OVER_TIME(value))` |

Time bucketing function (for use with TS source command):

| Function | Description | Example |
| -------- | ----------- | ------- |
| `TBUCKET(interval)` | Groups @timestamp into time buckets for time-series aggregations | `BY TBUCKET(1 hour)`, `BY TBUCKET(5minute)` |

**Note:** `TBUCKET` is specialized for `@timestamp` in time-series queries (TS + STATS). For general-purpose bucketing of any date/numeric field, use `BUCKET()` instead (see Date/Time Functions below).

---

## Common Functions

### String Functions

| Function | Description | Example |
| -------- | ----------- | ------- |
| `LENGTH(s)` | String length | `EVAL len = LENGTH(message)` |
| `SUBSTRING(s, start, len)` | Extract substring | `EVAL prefix = SUBSTRING(host, 0, 4)` |
| `CONCAT(s1, s2, ...)` | Concatenate strings | `EVAL full = CONCAT(first, " ", last)` |
| `TO_LOWER(s)` | Lowercase | `EVAL lower = TO_LOWER(name)` |
| `TO_UPPER(s)` | Uppercase | `EVAL upper = TO_UPPER(name)` |
| `TRIM(s)` | Remove whitespace | `EVAL clean = TRIM(input)` |
| `REPLACE(s, old, new)` | Replace substring | `EVAL fixed = REPLACE(msg, "err", "error")` |
| `SPLIT(s, delim)` | Split into array | `EVAL parts = SPLIT(path, "/")` |

### Date/Time Functions

| Function | Description | Example |
| -------- | ----------- | ------- |
| `NOW()` | Current timestamp | `WHERE @timestamp > NOW() - 1 hour` |
| `DATE_EXTRACT(unit, date)` | Extract date part | `EVAL hour = DATE_EXTRACT("hour", @timestamp)` |
| `DATE_TRUNC(unit, date)` | Truncate to unit | `EVAL day = DATE_TRUNC("day", @timestamp)` |
| `DATE_DIFF(unit, d1, d2)` | Difference between dates | `EVAL age_days = DATE_DIFF("day", created, NOW())` |
| `DATE_FORMAT(date, fmt)` | Format date as string | `EVAL formatted = DATE_FORMAT(@timestamp, "yyyy-MM-dd")` |
| `DATE_PARSE(fmt, s)` | Parse string to date | `EVAL parsed = DATE_PARSE("yyyy-MM-dd", date_str)` |
| `BUCKET(field, size)` | General-purpose bucketing for any date/numeric field | `STATS count = COUNT(*) BY BUCKET(@timestamp, 1 hour)` |

### Numeric Functions

| Function | Description | Example |
| -------- | ----------- | ------- |
| `ABS(n)` | Absolute value | `EVAL abs_val = ABS(change)` |
| `CEIL(n)` | Round up | `EVAL ceiling = CEIL(value)` |
| `FLOOR(n)` | Round down | `EVAL floored = FLOOR(value)` |
| `ROUND(n, decimals)` | Round to decimals | `EVAL rounded = ROUND(avg, 2)` |
| `POW(base, exp)` | Power | `EVAL squared = POW(x, 2)` |
| `SQRT(n)` | Square root | `EVAL root = SQRT(variance)` |
| `LOG10(n)` | Base-10 logarithm | `EVAL log = LOG10(value)` |

### Conditional Functions

| Function | Description | Example |
| -------- | ----------- | ------- |
| `CASE(cond1, val1, ...)` | Conditional logic | `EVAL status = CASE(code >= 500, "error", code >= 400, "warn", "ok")` |
| `COALESCE(v1, v2, ...)` | First non-null | `EVAL name = COALESCE(display_name, username, "unknown")` |
| `GREATEST(v1, v2, ...)` | Maximum value | `EVAL max = GREATEST(a, b, c)` |
| `LEAST(v1, v2, ...)` | Minimum value | `EVAL min = LEAST(a, b, c)` |

### Type Conversion Functions

| Function | Description | Example |
| -------- | ----------- | ------- |
| `TO_STRING(v)` | Convert to string | `EVAL str = TO_STRING(status_code)` |
| `TO_INTEGER(v)` | Convert to integer | `EVAL num = TO_INTEGER(count_str)` |
| `TO_DOUBLE(v)` | Convert to double | `EVAL dbl = TO_DOUBLE(value)` |
| `TO_BOOLEAN(v)` | Convert to boolean | `EVAL flag = TO_BOOLEAN(enabled)` |
| `TO_DATETIME(v)` | Convert to datetime | `EVAL ts = TO_DATETIME(timestamp_str)` |
| `TO_IP(v)` | Convert to IP | `EVAL ip = TO_IP(ip_string)` |

---

## Operators

### Comparison Operators

| Operator | Description | Example |
| -------- | ----------- | ------- |
| `==` | Equal | `WHERE status == 200` |
| `!=` | Not equal | `WHERE status != 500` |
| `<` | Less than | `WHERE response_time < 100` |
| `<=` | Less than or equal | `WHERE count <= 10` |
| `>` | Greater than | `WHERE bytes > 1000` |
| `>=` | Greater than or equal | `WHERE score >= 0.5` |
| `LIKE` | Pattern match (wildcards) | `WHERE host LIKE "prod-*"` |
| `RLIKE` | Regex match | `WHERE message RLIKE "error.*timeout"` |
| `IN` | In list | `WHERE status IN (200, 201, 204)` |
| `IS NULL` | Null check | `WHERE error IS NULL` |
| `IS NOT NULL` | Not null check | `WHERE response IS NOT NULL` |

### Logical Operators

| Operator | Description | Example |
| -------- | ----------- | ------- |
| `AND` | Logical AND | `WHERE status == 200 AND response_time < 100` |
| `OR` | Logical OR | `WHERE status == 500 OR status == 503` |
| `NOT` | Logical NOT | `WHERE NOT host LIKE "test-*"` |

### Arithmetic Operators

| Operator | Description | Example |
| -------- | ----------- | ------- |
| `+` | Addition | `EVAL total = sent + received` |
| `-` | Subtraction | `EVAL diff = end - start` |
| `*` | Multiplication | `EVAL bytes = kb * 1024` |
| `/` | Division | `EVAL rate = count / duration` |
| `%` | Modulo | `EVAL remainder = value % 10` |

---

## Dashboard Query Patterns

### Metric Panel Queries

Single-value metrics:

```esql
# Total count
FROM logs-*
| STATS total_events = COUNT(*)

# Average with breakdown
FROM logs-*
| STATS avg_response = AVG(response_time), p95 = PERCENTILE(response_time, 95.0) BY service.name
```

### Time Series Charts

```esql
# Events over time
FROM logs-*
| STATS event_count = COUNT(*) BY time_bucket = BUCKET(@timestamp, 1 hour)
| SORT time_bucket ASC

# Events by category over time
FROM logs-*
| STATS event_count = COUNT(*) BY time_bucket = BUCKET(@timestamp, 1 hour), event.category
| SORT time_bucket ASC

# Bytes transferred over time with breakdown
FROM logs-*
| STATS total_bytes = SUM(bytes) BY time_bucket = BUCKET(@timestamp, 15 minutes), host.name
| SORT time_bucket ASC
```

### Pie/Donut Charts

```esql
# Top 10 event categories
FROM logs-*
| STATS count = COUNT(*) BY event.category
| SORT count DESC
| LIMIT 10

# Browser distribution
FROM logs-*
| STATS users = COUNT_DISTINCT(user.id) BY user_agent.name
| SORT users DESC
| LIMIT 5
```

### Bar Charts

```esql
# Top hosts by request count
FROM logs-*
| STATS requests = COUNT(*) BY host.name
| SORT requests DESC
| LIMIT 10

# Error codes distribution
FROM logs-*
| WHERE status >= 400
| STATS errors = COUNT(*) BY status
| SORT errors DESC
```

### Data Tables

```esql
# Recent errors with context
FROM logs-*
| WHERE log.level == "error"
| KEEP @timestamp, host.name, message, error.type
| SORT @timestamp DESC
| LIMIT 100

# Top talkers summary
FROM logs-*
| STATS
    total_requests = COUNT(*),
    total_bytes = SUM(bytes),
    avg_response = AVG(response_time)
  BY source.ip
| SORT total_requests DESC
| LIMIT 20
```

---

## Common Mistakes to Avoid

1. **Using SQL syntax**: ES|QL is not SQL. No SELECT, FROM comes first, use `|` pipes.

2. **Wrong equality operator**: Use `==` for comparison, not `=`.

3. **Missing pipes**: Commands must be separated by `|`.

4. **GROUP BY in wrong place**: Use `BY` within `STATS`, not as separate clause.

5. **Wrong wildcard character**: Use `*` in LIKE patterns, not `%`.

6. **Forgetting SORT for time series**: Add `SORT time_bucket ASC` for charts.

7. **Using BUCKET as standalone command**: `BUCKET()` must be used within STATS...BY or EVAL, not as a separate command.

8. **Case sensitivity**: Field names are case-sensitive.

9. **Missing time filter**: Add `WHERE @timestamp >= NOW() - 1 day` for performance.

10. **Assuming default order**: Always explicit SORT for predictable results.

11. **Using window functions**: ES|QL has no `ROW_NUMBER() OVER (PARTITION BY ...)`. Use `VALUES()` + `MV_SORT()` + `MV_FIRST()`/`MV_LAST()` for latest-per-group patterns.

---

## Additional Resources

- [ESQL Panel Configuration](../panels/esql.md) - Dashboard panel setup
- [ES|QL Query Reuse with YAML Anchors](../advanced/esql-views.md) - Query patterns
- [Queries Configuration](../queries/config.md#esql-query) - Query format options
- [Elastic ES|QL Reference](https://www.elastic.co/docs/reference/query-languages/esql) - Official documentation


---
# Source: advanced/color-assignments.md
---

# Custom Color Assignments

While the compiler includes several built-in color palettes for basic color customization, you can also manually assign specific colors to individual data values. This is useful for semantic coloring (e.g., green for success, red for errors) or brand-specific requirements.

## When to Use Color Assignments

Manual color assignments are particularly valuable when:

- **Semantic Meaning**: Colors convey meaning (green = success, red = error, yellow = warning)
- **Brand Requirements**: Specific data values must match brand guidelines
- **Consistency**: Colors need to be consistent across multiple dashboards
- **Accessibility**: You need to ensure specific high-contrast color combinations

For simple color customization without semantic meaning, consider using one of the [built-in color palettes](../panels/base.md#color-mapping-configuration) instead.

## Basic Example: HTTP Status Code Coloring

This example demonstrates semantic color assignments for HTTP status codes:

```yaml
dashboards:
-
  name: Status Monitoring
  panels:
    - title: HTTP Response Codes
      size: {w: 24, h: 15}
      lens:
        type: pie
        data_view: "logs-*"
        dimensions:
          - field: "http.response.status_code"
            type: values
        metrics:
          - aggregation: count
        color:
          palette: 'eui_amsterdam_color_blind'
          assignments:
            - values: ['200', '201']
              color: '#00BF6F'  # Green for success
            - values: ['404']
              color: '#FFA500'  # Orange for not found
            - values: ['500', '502', '503']
              color: '#BD271E'  # Red for errors
```

In this example:

- A base palette (`eui_amsterdam_color_blind`) provides colors for unassigned values
- Specific status codes receive semantic colors (green for 2xx, orange for 404, red for 5xx)
- Multiple values can share the same color using the `values` array

## Configuration Reference

### ColorMapping Object

The `color` field on chart panels accepts a `ColorMapping` object:

| YAML Key | Data Type | Description | Default | Required |
| -------- | --------- | ----------- | ------- | -------- |
| `palette` | `string` | The color palette ID to use for unassigned colors. | `'eui_amsterdam_color_blind'` | No |
| `assignments` | `list[ColorAssignment]` | Manual color assignments to specific data values. | `[]` | No |

### ColorAssignment Object

Each item in the `assignments` list specifies a color for one or more data values:

| YAML Key | Data Type | Description | Required |
| -------- | --------- | ----------- | -------- |
| `value` | `string` | Single data value to assign this color to. | No* |
| `values` | `list[str]` | List of data values to assign this color to. | No* |
| `color` | `string` | Hex color code (e.g., '#FF0000'). | Yes |

\* At least one of `value` or `values` must be provided.

## Advanced Patterns

### Pattern 1: Grouping Related Values

Group related values under a single color to reduce visual complexity:

```yaml
color:
  palette: 'eui_amsterdam_color_blind'
  assignments:
    # Success states
    - values: ['completed', 'success', 'ok']
      color: '#00BF6F'
    # Warning states
    - values: ['pending', 'in_progress', 'waiting']
      color: '#FFA500'
    # Error states
    - values: ['failed', 'error', 'timeout']
      color: '#BD271E'
```

### Pattern 2: Single Value Assignment

For individual values, you can use either `value` (singular) or `values` (list):

```yaml
color:
  assignments:
    # Using 'value' for single values
    - value: 'critical'
      color: '#BD271E'
    # Using 'values' with a single-item list (equivalent)
    - values: ['warning']
      color: '#FFA500'
```

### Pattern 3: Combining with Palette Selection

Choose a palette that provides good defaults for unassigned values:

```yaml
color:
  palette: 'gray'  # Unassigned values use grayscale
  assignments:
    # Only highlight important values with color
    - value: 'critical_error'
      color: '#BD271E'
    - value: 'performance_issue'
      color: '#FFA500'
```

## Comprehensive Example

For a complete example showcasing various color assignment techniques across different chart types, see the [color-palette-examples.yaml](https://github.com/strawgate/kb-yaml-to-lens/blob/main/docs/content/examples/color-palette-examples.yaml) file in the repository.

## Best Practices

1. **Use Semantic Colors Consistently**: Establish a color scheme and use it consistently across all dashboards (e.g., always use red for errors).

2. **Consider Color Blindness**: While you can use any hex color, consider color-blind accessibility. Use the `eui_amsterdam_color_blind` palette as a base and only override specific values when necessary.

3. **Document Your Color Scheme**: Add comments to your YAML explaining the meaning of color assignments:

   ```yaml
   color:
     assignments:
       # Critical alerts require immediate attention
       - value: 'critical'
         color: '#BD271E'
   ```

4. **Test in Different Themes**: Kibana supports light and dark themes. Test your color choices in both to ensure they remain visible and meaningful.

5. **Limit Manual Assignments**: Only assign colors to values that need semantic meaning. Let the palette handle the rest to maintain visual harmony.

## Related Documentation

- [Color Mapping Configuration](../panels/base.md#color-mapping-configuration) - Base panel color configuration reference
- [Color Palette Examples](https://github.com/strawgate/kb-yaml-to-lens/blob/main/docs/content/examples/color-palette-examples.yaml) - Comprehensive color examples
- [Pie Charts](../panels/pie.md) - Pie chart color configuration
- [XY Charts](../panels/xy.md) - XY chart color configuration


---
# Source: advanced/legend-configuration.md
---

# Legend Configuration Guide

Legends help users understand what colors, lines, and shapes represent in their charts. This guide covers legend configuration options across different chart types in the kb-yaml-to-lens compiler.

## Overview

The legend displays a mapping between visual elements (colors, patterns, etc.) and the data they represent. Different chart types support different legend options:

- **XY Charts** (line, bar, area): Support position, size, visibility, and label truncation
- **Pie Charts**: Support position (via width), visibility, nested legends, and label truncation
- **Heatmap Charts**: Support position and visibility for the color scale legend

## Legend Options by Chart Type

### XY Chart Legends

XY charts (line, bar, and area charts) provide comprehensive legend customization:

```yaml
dashboards:
  - name: "XY Chart with Legend"
    panels:
      - title: "Request Count by Service"
        size: {w: 24, h: 15}
        lens:
          type: line
          data_view: "logs-*"
          dimension:
            field: "@timestamp"
            type: date_histogram
          breakdown:
            field: "service.name"
            type: values
          metrics:
            - aggregation: count
          legend:
            visible: show              # show, hide, or auto
            position: right             # top, bottom, left, or right
            size: medium                # small, medium, large, extra_large
            show_single_series: false   # Show legend even with one series
            truncate_labels: 1          # Lines to truncate labels (0-5)
```

**Available Options:**

| Option | Values | Description | Default | Required |
| ------ | ------ | ----------- | ------- | -------- |
| `visible` | `show`, `hide`, `auto` | Control legend visibility | `show` | No |
| `position` | `top`, `bottom`, `left`, `right` | Legend placement | `right` | No |
| `size` | `small`, `medium`, `large`, `extra_large` | Legend width/height | Auto | No |
| `show_single_series` | `true`, `false` | Show legend for single series | `false` | No |
| `truncate_labels` | `0` to `5` | Lines before truncation (0 = no truncation) | `1` | No |

### Pie Chart Legends

Pie charts have a simplified legend configuration focused on label formatting:

```yaml
dashboards:
  - name: "Pie Chart with Legend"
    panels:
      - title: "Traffic by Source"
        size: {w: 24, h: 15}
        lens:
          type: pie
          data_view: "logs-*"
          dimensions:
            - field: "traffic.source"
              type: values
          metrics:
            - aggregation: count
          legend:
            visible: auto              # show, hide, or auto
            width: medium               # small, medium, large, extra_large
            truncate_labels: 1          # Lines to truncate labels (0-5)
            nested: false               # Nested format for multi-level pies
            show_single_series: false   # Show legend for single series
```

**Available Options:**

| Option | Values | Description | Default | Required |
| ------ | ------ | ----------- | ------- | -------- |
| `visible` | `show`, `hide`, `auto` | Control legend visibility | `auto` | No |
| `width` | `small`, `medium`, `large`, `extra_large` | Legend width | `medium` | No |
| `truncate_labels` | `0` to `5` | Lines before truncation (0 = no truncation) | `1` | No |
| `nested` | `true`, `false` | Nested format for multi-level pies | `false` | No |
| `show_single_series` | `true`, `false` | Show legend for single series | `false` | No |

### Heatmap Chart Legends

Heatmap charts display a color scale legend:

```yaml
dashboards:
  - name: "Heatmap with Legend"
    panels:
      - title: "Activity Heatmap"
        size: {w: 24, h: 15}
        lens:
          type: heatmap
          data_view: "logs-*"
          x_axis:
            field: "@timestamp"
            type: date_histogram
          y_axis:
            field: "service.name"
            type: values
          value:
            aggregation: count
          legend:
            visible: show    # show or hide (auto not supported)
            position: right  # top, bottom, left, or right
```

**Available Options:**

| Option | Values | Description | Default | Required |
| ------ | ------ | ----------- | ------- | -------- |
| `visible` | `show`, `hide` | Control legend visibility (auto not supported) | `show` | No |
| `position` | `top`, `bottom`, `left`, `right` | Legend placement | `right` | No |

**Note:** Heatmap legends do not support the `auto` visibility option. Use `show` or `hide` explicitly.

## Best Practices

### 1. Choose Appropriate Visibility

- **Use `show`** when the legend is essential for understanding the chart (e.g., multiple series with similar colors)
- **Use `hide`** when the chart is self-explanatory or space is limited (e.g., single metric over time)
- **Use `auto`** (XY and Pie only) to let Kibana decide based on the data

### 2. Optimize Legend Position

- **Right position** (default): Works well for most time series charts
- **Bottom position**: Better for wide dashboards or charts with many series
- **Top position**: Useful when you want the legend prominently displayed
- **Left position**: Rarely used, but can work for charts with long series names

### 3. Manage Long Labels

Use `truncate_labels` to prevent legends from taking up too much space:

```yaml
legend:
  truncate_labels: 2  # Truncate to 2 lines
```

Set to `0` to disable truncation if you need to see full labels:

```yaml
legend:
  truncate_labels: 0  # No truncation
```

### 4. Size Considerations

Choose legend size based on the number of series and label length:

```yaml
# For many series or long labels
legend:
  size: large

# For few series with short labels
legend:
  size: small
```

### 5. Single Series Charts

For single-series charts, consider hiding the legend to save space:

```yaml
legend:
  show_single_series: false  # Default - hide legend for single series
```

Or show it for consistency across dashboards:

```yaml
legend:
  show_single_series: true  # Always show legend
```

## Common Patterns

### Pattern 1: Hide Legend for Simple Time Series

```yaml
lens:
  type: line
  data_view: "logs-*"
  dimension:
    field: "@timestamp"
    type: date_histogram
  metrics:
    - aggregation: count
      label: "Total Requests"
  legend:
    visible: hide  # Single metric doesn't need legend
```

### Pattern 2: Bottom Legend for Wide Charts

```yaml
lens:
  type: bar
  data_view: "logs-*"
  dimension:
    field: "service.name"
    type: values
  breakdown:
    field: "http.response.status_code"
    type: values
    size: 10
  metrics:
    - aggregation: count
  legend:
    position: bottom  # Better for many categories
    size: small
    truncate_labels: 1
```

### Pattern 3: Nested Pie Chart Legend

```yaml
lens:
  type: pie
  data_view: "logs-*"
  dimensions:
    - field: "service.name"
      type: values
    - field: "http.response.status_code"
      type: values
  metrics:
    - aggregation: count
  legend:
    visible: show
    nested: true       # Hierarchical legend for multi-level pie
    width: large
    truncate_labels: 2
```

### Pattern 4: Compact Heatmap Legend

```yaml
lens:
  type: heatmap
  data_view: "logs-*"
  x_axis:
    field: "@timestamp"
    type: date_histogram
  y_axis:
    field: "host.name"
    type: values
  value:
    aggregation: average
    field: "cpu.usage"
  legend:
    visible: show
    position: bottom  # Save horizontal space
```

## Examples

For comprehensive examples of legend configurations across different chart types, see:

- [XY Chart Examples](../panels/xy.md)
- [Pie Chart Examples](../panels/pie.md)
- [Heatmap Examples](../examples/heatmap-examples.yaml)

## Related Documentation

- [XY Charts](../panels/xy.md) - XY chart configuration and legend options
- [Pie Charts](../panels/pie.md) - Pie chart configuration and legend options
- [Heatmap Charts](../panels/heatmap.md) - Heatmap chart configuration and legend options
- [Base Panel Configuration](../panels/base.md) - Common panel configuration options


---
# Source: advanced/esql-views.md
---

# ES|QL Query Reuse with YAML Anchors

When building dashboards with multiple ES|QL panels, you often need to query the same data source with similar filters across different visualizations. YAML anchors provide a way to define reusable query components that can be shared across panels, reducing duplication and making dashboards easier to maintain.

## How It Works

ES|QL queries can be defined as an array of strings instead of a single string. The compiler automatically joins array elements with the ES|QL pipe operator (`|`):

```yaml
# Array format
query:
  - FROM logs-*
  - WHERE status >= 200
  - STATS count = COUNT()

# Compiles to: FROM logs-* | WHERE status >= 200 | STATS count = COUNT()
```

Combined with YAML anchors (`&anchor_name`) and aliases (`*anchor_name`), you can define query parts once and reference them in multiple panels.

## Pattern 1: Shared Data Source

Define the data source once and reuse it across all panels:

```yaml
# Define the base data source
.base_query: &logs_source
  - FROM logs-*
  - WHERE @timestamp > NOW() - 24h

dashboards:
  - name: "Application Logs"
    panels:
      - title: "Total Requests"
        size: {w: 16, h: 8}
        esql:
          type: metric
          query:
            - *logs_source
            - STATS total = COUNT()
          primary:
            field: total

      - title: "Requests by Status"
        size: {w: 16, h: 8}
        position: {x: 16, y: 0}
        esql:
          type: pie
          query:
            - *logs_source
            - STATS count = COUNT() BY http.response.status_code
          metrics:
            - field: count
          dimensions:
            - field: http.response.status_code

      - title: "Average Response Time"
        size: {w: 16, h: 8}
        position: {x: 32, y: 0}
        esql:
          type: metric
          query:
            - *logs_source
            - STATS avg_time = AVG(http.response.time)
          primary:
            field: avg_time
```

All three panels share the same data source and time filter, but each has its own aggregation.

## Pattern 2: Shared Filters

Define common filter conditions that apply to multiple panels:

```yaml
# Define reusable filter conditions
.filters:
  production: &prod_filter
    - WHERE environment == "production"
  successful: &success_filter
    - WHERE http.response.status_code >= 200 AND http.response.status_code < 400
  errors: &error_filter
    - WHERE http.response.status_code >= 400

dashboards:
  - name: "Production Metrics"
    panels:
      - title: "Successful Requests"
        size: {w: 24, h: 8}
        esql:
          type: metric
          query:
            - FROM logs-*
            - *prod_filter
            - *success_filter
            - STATS count = COUNT()
          primary:
            field: count

      - title: "Error Rate"
        size: {w: 24, h: 8}
        position: {x: 24, y: 0}
        esql:
          type: metric
          query:
            - FROM logs-*
            - *prod_filter
            - *error_filter
            - STATS errors = COUNT()
          primary:
            field: errors
```

## Pattern 3: Pseudo ES|QL Views

Create "view-like" abstractions by combining data source, filters, and common transformations:

```yaml
# Define a "view" as a complete base query
.views:
  api_requests: &api_view
    - FROM logs-*
    - WHERE service.type == "api"
    - WHERE @timestamp > NOW() - 1h
    - EVAL response_time_ms = http.response.time / 1000000

dashboards:
  - name: "API Dashboard"
    panels:
      - title: "Request Volume"
        size: {w: 16, h: 8}
        esql:
          type: metric
          query:
            - *api_view
            - STATS requests = COUNT()
          primary:
            field: requests

      - title: "P95 Response Time"
        size: {w: 16, h: 8}
        position: {x: 16, y: 0}
        esql:
          type: metric
          query:
            - *api_view
            - STATS p95 = PERCENTILE(response_time_ms, 95)
          primary:
            field: p95

      - title: "Requests by Endpoint"
        size: {w: 16, h: 8}
        position: {x: 32, y: 0}
        esql:
          type: pie
          query:
            - *api_view
            - STATS count = COUNT() BY url.path
            - SORT count DESC
            - LIMIT 10
          metrics:
            - field: count
          dimensions:
            - field: url.path
```

## Pattern 4: Composable Query Parts

Build complex queries from multiple reusable components:

```yaml
.query_parts:
  metrics_source: &source
    - FROM metrics-*
  time_filter: &time
    - WHERE @timestamp > NOW() - 6h
  host_filter: &host
    - WHERE host.name IS NOT NULL

dashboards:
  - name: "Host Metrics"
    panels:
      - title: "CPU by Host"
        size: {w: 24, h: 12}
        esql:
          type: datatable
          query:
            - *source
            - *time
            - *host
            - STATS avg_cpu = AVG(system.cpu.total.pct) BY host.name
            - SORT avg_cpu DESC

      - title: "Memory by Host"
        size: {w: 24, h: 12}
        position: {x: 24, y: 0}
        esql:
          type: datatable
          query:
            - *source
            - *time
            - *host
            - STATS avg_mem = AVG(system.memory.used.pct) BY host.name
            - SORT avg_mem DESC
```

## Best Practices

1. **Use descriptive anchor names**: Names like `&api_logs_base` are clearer than `&base1`.

2. **Prefix anchors with a dot**: Using `.views:` or `.filters:` at the top level keeps these definitions clearly separate from actual dashboard content. Keys starting with `.` are ignored by the compiler.

3. **Keep anchors at the top**: Define all anchors at the beginning of your YAML file for easy reference.

4. **Document your views**: Add comments explaining what each anchor represents.

5. **Balance reuse with readability**: Don't over-abstract—if a query is used only once, inline it.

## Limitations

- YAML anchors work only within a single file. For multi-file dashboards, consider using a pre-processor or templating tool.
- Anchors cannot be modified when referenced—you can only extend an array by adding more elements after the alias.

## Related Documentation

- [Queries Configuration](../queries/config.md)
- [ESQL Panel Configuration](../panels/esql.md)


---
# Source: architecture.md
---

# Dashboard Compiler Architecture

This document describes the architecture of the dashboard compiler, which converts a simplified YAML representation of Kibana dashboards into the complex Kibana dashboard JSON format.

## Goal

The primary goal is to provide a human-readable and maintainable way to define Kibana dashboards using YAML, abstracting away the complexities of the native JSON structure.

## Design

The compiler is designed using a layered approach with distinct components responsible for different stages of the conversion process.

1. **YAML Loading and Parsing:**
    - The process begins by loading the YAML configuration file.
    - The `PyYAML` library is used to parse the YAML content into a Python dictionary.

2. **Pydantic Model Representation:**
    - The codebase uses a three-layer pattern with separate models for input configuration and output views:
      - **Config Models** (`**/config.py`): Define the YAML schema structure using Pydantic, handling validation and ensuring the parsed YAML conforms to the defined schema. These models use a `BaseCfgModel` base class.
      - **View Models** (`**/view.py`): Define the Kibana JSON output structure using Pydantic. These models use a `BaseVwModel` base class and include custom serialization logic.
      - **Compile Functions** (`**/compile.py`): Transform config models into view models, handling the specific formatting and mapping required for each component.
    - Each major component of a dashboard (Dashboard, Panel, Grid, etc.) and its variations (different panel types, Lens visualizations, dimensions, metrics, etc.) follows this pattern.
    - A custom validator in the base `Panel` class is used to dynamically instantiate the correct panel subclass based on the `type` field in the YAML data.

3. **Compilation Process:**
    - Compile functions in `compile.py` files take config model instances and transform them into view model instances.
    - These functions handle the specific formatting and nesting required for each element (panels, visualizations, layers, etc.).
    - The top-level dashboard compilation orchestrates the compilation of all components (panels, controls, filters, queries) and assembles the final Kibana JSON structure.
    - View models use Pydantic's `model_dump_json()` method to serialize to JSON.

4. **ID and Reference Management (Future Enhancement):**
    - The Kibana dashboard JSON relies heavily on unique IDs and references between components.
    - A future enhancement will involve implementing a system for generating unique IDs and managing these references during the compilation process to ensure the generated dashboards are valid and functional in Kibana.

5. **Error Handling (Future Enhancement):**
    - Robust error handling will be added to catch and report issues during YAML parsing, data validation, and JSON compilation.

## Components

The codebase is organized into a hierarchical structure under `src/dashboard_compiler/`:

- **`dashboard_compiler.py`:** Main entry point containing the core compilation orchestration functions (`load`, `render`, `dump`).
- **`cli.py`:** Command-line interface for compiling dashboards and uploading to Kibana.
- **`dashboard/`:** Top-level dashboard compilation with `config.py`, `view.py`, and `compile.py`.
- **`panels/`:** Panel compilation with subdirectories for each panel type (markdown, links, images, search, charts).
- **`panels/charts/`:** Chart-specific compilation with subdirectories for different chart types (metric, pie, xy) and components (lens/esql metrics, dimensions, columns).
- **`controls/`:** Control group compilation for dashboard interactivity.
- **`filters/`:** Filter compilation supporting various filter types.
- **`queries/`:** Query compilation for KQL, Lucene, and ESQL.
- **`shared/`:** Shared base models and utilities (`model.py`, `view.py`).
- **`tests/`:** Test files including snapshot tests to verify compiler output against expected JSON.

## Data Flow

1. YAML file is read.
2. YAML content is parsed into a Python dictionary.
3. The dictionary is validated and converted into a hierarchy of Pydantic config model objects.
4. Compile functions transform the config model hierarchy into view model objects.
5. The compile functions are called recursively on nested objects to build the view model structure.
6. View models are serialized to JSON using Pydantic's `model_dump_json()` method.
7. A Kibana-compatible NDJSON file is generated.

```mermaid
graph TD
    A[YAML File] --> B{Load & Parse YAML}
    B --> C[Python Dictionary]
    C --> D{Pydantic Validation}
    D --> E[Config Model Hierarchy]
    E --> F{Compile Functions}
    F --> G[View Model Hierarchy]
    G --> H{model_dump_json}
    H --> I[Kibana JSON/NDJSON]


---
# Source: programmatic-usage.md
---

# Programmatic Usage

The Dashboard Compiler provides a full programmatic API for creating dashboards in Python code, without writing any YAML configuration files.

## Why Use Python Code?

While YAML is great for simple, static dashboards, creating dashboards programmatically offers several advantages:

- **Dynamic Generation**: Create dashboards based on runtime data, configuration, or external sources
- **Reusability**: Build helper functions and templates for common dashboard patterns
- **Type Safety**: Leverage Pydantic models for validation and IDE autocomplete
- **Programmatic Logic**: Use loops, conditionals, and functions to generate complex layouts
- **Integration**: Easily integrate dashboard creation into your existing Python workflows

## Quick Example

```python
from dashboard_compiler.dashboard.config import Dashboard
from dashboard_compiler.dashboard_compiler import render
from dashboard_compiler.panels.config import Size
from dashboard_compiler.panels.markdown.config import MarkdownPanel, MarkdownPanelConfig

# Create a dashboard
dashboard = Dashboard(
    name='My First Dashboard',
    description='Created in Python',
)

# Add a markdown panel
panel = MarkdownPanel(
    size=Size(w=24, h=15),
    markdown=MarkdownPanelConfig(
        content='# Hello from Python!',
    ),
)
dashboard.add_panel(panel)

# Render to Kibana format
kbn_dashboard = render(dashboard)
output = kbn_dashboard.model_dump_json(by_alias=True, exclude_none=True)
print(output)
```

## Core Concepts

### Dashboard Object

The `Dashboard` class is the main entry point for creating dashboards:

```python
from dashboard_compiler.dashboard.config import Dashboard

dashboard = Dashboard(
    name='Dashboard Name',  # Required: Display name
    description='Dashboard description',  # Optional: Description
)
```

### Panel Sizing

Kibana uses a 48-column grid system for output. Panels are sized using the `Size` class, with optional `Position` for explicit positioning:

```python
from dashboard_compiler.panels.config import Position, Size

# Full-width panel (auto-positioned)
size = Size(w=48, h=15)

# Half-width panels
size_half = Size(w=24, h=15)

# Quarter-width panels
size_quarter = Size(w=12, h=15)

# Explicit position when needed
position = Position(x=0, y=0)
```

**Size Parameters:**

- `w`: Width in grid units (1-48)
- `h`: Height in grid units (1+)

**Position Parameters (optional):**

- `x`: Horizontal position (0-47)
- `y`: Vertical position (0+)

### Adding Panels

Use the `add_panel()` method to add panels to your dashboard:

```python
dashboard.add_panel(panel)
```

This method returns the dashboard instance, allowing for method chaining:

```python
dashboard.add_panel(panel1).add_panel(panel2).add_panel(panel3)
```

## Dynamic Dashboard Generation

One of the key benefits of programmatic dashboards is the ability to generate them dynamically:

### Generating Panels from Configuration

```python
from dashboard_compiler.dashboard.config import Dashboard
from dashboard_compiler.panels.charts.config import (
    LensMetricPanelConfig,
    LensPanel,
)
from dashboard_compiler.panels.charts.lens.metrics.config import (
    LensOtherAggregatedMetric,
)
from dashboard_compiler.panels.config import Size

dashboard = Dashboard(name='Metrics Dashboard')

metrics_config = [
    {'name': 'CPU Usage', 'field': 'cpu_percent'},
    {'name': 'Memory Usage', 'field': 'memory_percent'},
    {'name': 'Disk I/O', 'field': 'disk_io'},
]

for metric in metrics_config:
    panel = LensPanel(
        title=metric['name'],
        size=Size(
            w=16,
            h=15,
        ),
        lens=LensMetricPanelConfig(
            type='metric',
            data_view='metrics-*',
            primary=LensOtherAggregatedMetric(
                aggregation='average', field=metric['field']
            ),
        ),
    )

    dashboard.add_panel(panel)
```

### Building Reusable Helper Functions

```python
def create_metric_panel(title: str, field: str) -> LensPanel:
    """Helper function to create a standard metric panel."""
    return LensPanel(
        title=title,
        size=Size(w=24, h=15),  # Auto-positioned
        lens=LensMetricPanelConfig(
            type='metric',
            data_view='logs-*',
            primary=LensOtherAggregatedMetric(aggregation='average', field=field),
        ),
    )

# Use the helper function
dashboard.add_panel(create_metric_panel('Avg Response Time', 'response_time'))
dashboard.add_panel(create_metric_panel('Avg Bytes', 'bytes'))
```

## Filters and Controls

### Global Filters

Add filters that apply to all panels in the dashboard:

```python
from dashboard_compiler.dashboard.config import Dashboard
from dashboard_compiler.filters.config import ExistsFilter, PhraseFilter, RangeFilter

dashboard = Dashboard(name='Filtered Dashboard')

# Phrase filter
dashboard.add_filter(
    PhraseFilter(
        field='environment',
        equals='production',
    )
)

# Range filter
dashboard.add_filter(
    RangeFilter(
        field='response_time',
        gte='0',
        lte='1000',
    )
)

# Exists filter
dashboard.add_filter(ExistsFilter(exists='error.message'))
```

### Interactive Controls

Add interactive controls for filtering data:

```python
from dashboard_compiler.controls.config import (
    OptionsListControl,
    RangeSliderControl,
)
from dashboard_compiler.dashboard.config import Dashboard

dashboard = Dashboard(name='Dashboard with Controls')

# Options list (dropdown filter)
dashboard.add_control(
    OptionsListControl(
        field='log.level',
        label='Log Level',
        width='medium',
        data_view='logs-*',
    )
)

# Range slider
dashboard.add_control(
    RangeSliderControl(
        field='bytes',
        label='Response Size',
        step=100,
        width='medium',
        data_view='logs-*',
    )
)
```

## Rendering and Export

### Rendering to Kibana Format

Convert your dashboard to Kibana's NDJSON format:

```python
from pathlib import Path

from dashboard_compiler.dashboard.config import Dashboard
from dashboard_compiler.dashboard_compiler import render

dashboard = Dashboard(name='My Dashboard')
kbn_dashboard = render(dashboard)
output = kbn_dashboard.model_dump_json(by_alias=True, exclude_none=True)

# Save to file
Path('dashboard.ndjson').write_text(output)
```

### Saving Multiple Dashboards

```python
from dashboard_compiler.dashboard.config import Dashboard
from dashboard_compiler.dashboard_compiler import dump

dashboard1 = Dashboard(name='Dashboard 1')
dashboard2 = Dashboard(name='Dashboard 2')
dashboard3 = Dashboard(name='Dashboard 3')

dashboards = [dashboard1, dashboard2, dashboard3]
dump(dashboards, 'dashboards.ndjson')
```

## Panel Types

The Dashboard Compiler supports various panel types. For detailed examples and API reference for each panel type, see the **[Panels API Reference](api/panels.md)**.

**Available Panel Types:**

- **[Markdown Panels](api/panels.md#markdown-panels)** - Display rich text content
- **[Metric Charts](api/panels.md#metric-charts)** - Display key performance indicators (KPIs)
- **[Pie Charts](api/panels.md#pie-charts)** - Show distribution of categorical data
- **[XY Charts](api/panels.md#xy-charts)** - Create line, bar, and area charts for time series data
- **[Links Panels](api/panels.md#links-panels)** - Display collections of links
- **[Image Panels](api/panels.md#image-panels)** - Embed images in dashboards
- **[Search Panels](api/panels.md#search-panels)** - Display search results

## API Reference

For detailed API documentation and more examples, see:

- **[API Reference](api/index.md)** - Complete API documentation
- **[Panels](api/panels.md)** - Panel types with Python examples
- **[Dashboard](api/dashboard.md)** - Dashboard configuration
- **[Controls](api/controls.md)** - Control group configuration
- **[Filters](api/filters.md)** - Filter compilation
- **[Queries](api/queries.md)** - Query compilation


---
# Source: pypi-publishing.md
---

# PyPI Publishing Guide

The project uses **GitHub Actions with PyPI Trusted Publishing** for secure, token-free package deployment.

## Publishing Workflow

**Workflow**: `.github/workflows/publish-to-pypi.yml`

**Trigger**: GitHub release publication

## Publishing a Release

1. Update version in `compiler/pyproject.toml` (if needed)
2. Commit and push changes
3. Create a git tag:

   ```bash
   git tag v0.1.0
   git push origin v0.1.0
   ```

4. Create a GitHub Release from the tag
5. The workflow triggers automatically
6. Approve the deployment (if protection rules are configured)
7. Package publishes to PyPI

## Verification

After successful publication:

1. Visit <https://pypi.org/project/dashboard-compiler/>
2. Test installation:

   ```bash
   pip install dashboard-compiler
   kb-dashboard --help
   ```

## References

- [PyPI Trusted Publishers](https://docs.pypi.org/trusted-publishers/)
- [uv Publishing Guide](https://docs.astral.sh/uv/guides/publish/)
- [GitHub OIDC](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect)


---
# Source: api/index.md
---

# API Reference

This section contains the complete API documentation for the Dashboard Compiler.

## Overview

The Dashboard Compiler provides a Python API for creating Kibana dashboards programmatically. For a high-level guide on programmatic usage, see the **[Programmatic Usage Guide](../programmatic-usage.md)**.

## Core Modules

- **[Dashboard](dashboard.md)** – Dashboard configuration and compilation
- **[Panels](panels.md)** – Panel types and compilation logic (includes Python examples)
- **[Controls](controls.md)** – Control group configuration
- **[Filters](filters.md)** – Filter compilation
- **[Queries](queries.md)** – Query compilation

## Core Functions

The Dashboard Compiler provides these core functions for working with dashboards:

::: dashboard_compiler.dashboard_compiler
    options:
      show_source: true
      members:
        - load
        - render
        - dump


---
# Source: api/dashboard.md
---

# Dashboard

Dashboard configuration and compilation.

## Configuration Model

::: dashboard_compiler.dashboard.config.Dashboard
    options:
      show_source: true

## Compilation

::: dashboard_compiler.dashboard.compile
    options:
      show_source: true
      members:
        - compile_dashboard


---
# Source: api/panels.md
---

# Panels

Panel types and compilation logic.

## Base Panel Configuration

::: dashboard_compiler.panels.base.BasePanel
    options:
      show_source: true

## Markdown Panels

Display rich text content using markdown syntax.

### API Reference

::: dashboard_compiler.panels.markdown.config.MarkdownPanel
    options:
      show_source: true

For configuration details and examples, see the [Markdown Panel Configuration](../panels/markdown.md).

## Links Panels

Display collections of clickable links.

### API Reference

::: dashboard_compiler.panels.links.config.LinksPanel
    options:
      show_source: true

For configuration details and examples, see the [Links Panel Configuration](../panels/links.md).

## Image Panels

Embed images in your dashboard.

### API Reference

::: dashboard_compiler.panels.images.config.ImagePanel
    options:
      show_source: true

For configuration details and examples, see the [Image Panel Configuration](../panels/image.md).

## Search Panels

Display search results from Elasticsearch.

### API Reference

::: dashboard_compiler.panels.search.config.SearchPanel
    options:
      show_source: true

For configuration details and examples, see the [Search Panel Configuration](../panels/search.md).

## Lens Panel

Lens panels are used to create data visualizations including metrics, pie charts, and XY charts.

### API Reference

::: dashboard_compiler.panels.charts.config.LensPanel
    options:
      show_source: true

### Metric Charts

Display key performance indicators.

For configuration details and examples, see the [Metric Chart Panel Configuration](../panels/metric.md).

### Pie Charts

Create pie chart visualizations to show distribution of categorical data.

For configuration details and examples, see the [Pie Chart Panel Configuration](../panels/pie.md).

### Heatmap Charts

Create heatmap visualizations to show patterns across two categorical dimensions.

For configuration details and examples, see the [Heatmap Chart Panel Configuration](../panels/heatmap.md).

::: dashboard_compiler.panels.charts.heatmap.config.LensHeatmapChart
    options:
      show_source: true

::: dashboard_compiler.panels.charts.heatmap.config.ESQLHeatmapChart
    options:
      show_source: true

### XY Charts

Create line, bar, and area charts for time series and other data.

For configuration details and examples, see the [XY Chart Panel Configuration](../panels/xy.md).

## ESQL Panel

::: dashboard_compiler.panels.charts.config.ESQLPanel
    options:
      show_source: true


---
# Source: api/controls.md
---

# Controls

Control configuration and compilation.

## Control Settings

::: dashboard_compiler.controls.config.ControlSettings
    options:
      show_source: true

## Base Control

::: dashboard_compiler.controls.config.BaseControl
    options:
      show_source: true

## Options List Control

::: dashboard_compiler.controls.config.OptionsListControl
    options:
      show_source: true

## Range Slider Control

::: dashboard_compiler.controls.config.RangeSliderControl
    options:
      show_source: true

## Time Slider Control

::: dashboard_compiler.controls.config.TimeSliderControl
    options:
      show_source: true
      members: false


---
# Source: api/filters.md
---

# Filters

Filter configuration and compilation.

## Base Filter

::: dashboard_compiler.filters.config.BaseFilter
    options:
      show_source: true

## Exists Filter

::: dashboard_compiler.filters.config.ExistsFilter
    options:
      show_source: true

## Custom Filter

::: dashboard_compiler.filters.config.CustomFilter
    options:
      show_source: true

## Phrase Filter

::: dashboard_compiler.filters.config.PhraseFilter
    options:
      show_source: true

## Phrases Filter

::: dashboard_compiler.filters.config.PhrasesFilter
    options:
      show_source: true

## Range Filter

::: dashboard_compiler.filters.config.RangeFilter
    options:
      show_source: true
      members: false

## Negate Filter

::: dashboard_compiler.filters.config.NegateFilter
    options:
      show_source: true

## And Filter

::: dashboard_compiler.filters.config.AndFilter
    options:
      show_source: true

## Or Filter

::: dashboard_compiler.filters.config.OrFilter
    options:
      show_source: true


---
# Source: api/queries.md
---

# Queries

Query configuration and compilation.

## KQL Query

::: dashboard_compiler.queries.config.KqlQuery
    options:
      show_source: true

## Lucene Query

::: dashboard_compiler.queries.config.LuceneQuery
    options:
      show_source: true

## ESQL Query

::: dashboard_compiler.queries.config.ESQLQuery
    options:
      show_source: true


---
# Source: kibana-architecture.md
---

# Kibana Dashboard Architecture Reference

This document provides a comprehensive technical reference for Kibana's
dashboard and panel architecture, specifically designed to support the
development and understanding of YAML-to-Kibana compilation tools.

## Overview

Kibana dashboards are stored as **saved objects** in Elasticsearch using a
specific schema. The most critical architectural pattern is that complex
configuration data is stored as **stringified JSON** within the `attributes`
field of saved objects. Understanding this pattern is essential for any tool
that generates Kibana dashboards programmatically.

### Key Architectural Principles

1. **Saved Objects Model**: Dashboards are persisted as saved objects with
   type `"dashboard"` in Elasticsearch
2. **Stringified JSON**: Fields like `panelsJSON`, `optionsJSON`, and
   `searchSourceJSON` contain JSON serialized as strings
3. **Reference System**: External dependencies (data views, saved
   visualizations) are normalized into a `references` array
4. **By-Value vs By-Reference**: Panels can either embed full visualization
   configurations inline (by-value) or link to separately saved visualizations
   (by-reference)
5. **Lens as Primary Target**: Legacy visualization types are deprecated;
   modern dashboards should exclusively use Lens

## Version Evolution

### Timeline Overview

| Version | Key Changes | Impact on Compilers |
| --------- | ------------- | --------------------- |
| **7.x** | Introduced modern `gridData` format, Lens visualizations | Foundation for current architecture |
| **8.0** | Globally unique IDs across spaces, removed legacy import API | Must use Saved Objects API |
| **8.8+** | Index splitting (`.kibana` → multiple indices) | Transparent to API users |
| **8.10+** | Model versions replace legacy migrations | New version tracking system |
| **8.19+** | Collapsible sections, custom grid layout | New panel grouping mechanism |
| **9.0** | Disabled creation of legacy viz types, internal API restrictions | Must target Lens exclusively |
| **9.0+** | ES\|QL variable controls, Content Management v3 API | New filter/query capabilities |
| **10.0** | Full removal of TSVB, aggregation-based, Timelion | Complete deprecation |

### Migration from 8.x to 9.x

The core dashboard JSON structure remains backward compatible between 8.x and
9.x. Key differences:

#### Content Management v3 API (9.x)

The new API layer destringifies JSON for easier programmatic access:

| Storage Field | v3 API Field | Compiler Target |
| -------------- | -------------- | ----------------- |
| `panelsJSON` (string) | `panels` (array) | Use stringified format |
| `optionsJSON` (string) | `options` (object) | Use stringified format |
| `searchSourceJSON` (string) | `searchSource` (object) | Use stringified format |

**Recommendation**: Compilers should output the stringified format for maximum
compatibility with both direct saved object operations and older Kibana
versions.

#### Model Versions System

After Kibana 8.10.0, the legacy `migrations` property is deprecated. The new
`modelVersions` system uses consecutive integers (1, 2, 3...) decoupled from
Kibana release versions.

Version field changes:

| Field | Status | Usage |
| ------- | -------- | ------- |
| `migrationVersion` (map) | Being phased out | Legacy version tracking |
| `typeMigrationVersion` | Current standard | Primary version field |
| `coreMigrationVersion` | Active | Tracks core Kibana version |

#### Legacy Visualization Deprecations

| Visualization Type | 9.x Status | Full Removal |
| ------------------- | ------------ | -------------- |
| **TSVB** | Creation disabled, existing work | 10.0 |
| **Aggregation-based** | Creation disabled, existing work | 10.0 |
| **Timelion (viz)** | Creation disabled, existing work | 10.0 |
| **Vega** | Fully supported | No removal planned |
| **Logs Stream panel** | **REMOVED** | 9.0 |
| **Legacy Input Controls** | Hidden by default | TBD |

**Critical for compilers**: Target Lens (`lns*` visualization types) as the
primary output format since legacy visualization creation is disabled in 9.0
and scheduled for full removal in 10.0.

## Saved Object Structure

### Top-Level Schema

Every dashboard saved object follows this structure:

```json
{
  "id": "730ea5e4-dc12-4b1c-aee4-a6af849be9be",
  "type": "dashboard",
  "namespaces": ["default"],
  "updated_at": "2024-01-08T22:30:30.879Z",
  "created_at": "2024-01-08T22:30:30.879Z",
  "version": "Wzg1LDdd",
  "typeMigrationVersion": "8.7.0",
  "managed": false,
  "attributes": { /* Dashboard-specific data */ },
  "references": [ /* External object references */ ]
}
```

### Dashboard Attributes

The `attributes` object contains all dashboard-specific configuration:

| Field | Type | Description | Required |
| ------- | ------ | ------------- | ---------- |
| `title` | string | Dashboard display name | Yes |
| `description` | string | Optional dashboard description | No |
| `version` | number | Internal schema version (typically `1`) | Yes |
| `timeRestore` | boolean | Whether to restore saved time range on load | No |
| `timeFrom` | string | Saved time range start (e.g., `"now-15m"`) | No |
| `timeTo` | string | Saved time range end (e.g., `"now"`) | No |
| `refreshInterval` | object | Auto-refresh: `{pause: boolean, value: number}` | No |
| `kibanaSavedObjectMeta` | object | Contains `searchSourceJSON` (stringified) | Yes |
| `optionsJSON` | string | **Stringified dashboard display options** | Yes |
| `panelsJSON` | string | **Stringified array of panel configurations** | Yes |
| `controlGroupInput` | object | Filter controls configuration | No |

**Critical**: The `panelsJSON`, `optionsJSON`, and `searchSourceJSON` fields
are **stringified JSON strings**, not native objects. Compilers must serialize
these fields as escaped JSON strings within the final output.

### Search Source JSON

Controls dashboard-level queries and filters:

```json
{
  "query": {
    "query": "",
    "language": "kuery"
  },
  "filter": [
    {
      "$state": { "store": "appState" },
      "meta": {
        "alias": null,
        "disabled": false,
        "negate": false,
        "type": "phrase",
        "key": "field_name",
        "params": { "query": "value" },
        "indexRefName": "kibanaSavedObjectMeta.searchSourceJSON.filter[0].meta.index"
      },
      "query": {
        "match_phrase": { "field_name": "value" }
      }
    }
  ]
}
```

The `language` field accepts `"kuery"` (KQL) or `"lucene"`. Filter index
references use the `indexRefName` convention, which must match entries in the
top-level `references` array.

### Dashboard Options

The `optionsJSON` field contains display preferences:

```json
{
  "useMargins": true,
  "syncColors": false,
  "syncCursor": true,
  "syncTooltips": false,
  "hidePanelTitles": false
}
```

### References Array

The `references` array extracts object relationships from panel configurations:

**Reference Naming Conventions**:

| Pattern | Usage | Example |
| --------- | ------- | --------- |
| `panel_N` | By-reference panel linking to saved visualization | `panel_5` |
| `kibanaSavedObjectMeta.searchSourceJSON.index` | Dashboard's default data view | Main index pattern |
| `kibanaSavedObjectMeta.searchSourceJSON.filter[N].meta.index` | Filter data view references | Per-filter index |
| `{panelIndex}:indexpattern-datasource-layer-{layerId}` | Lens layer data view reference | `panel-uuid:indexpattern-datasource-layer-layer1` |
| `controlGroup_N:optionsListDataView` | Control group data views | Control filter index |

Example references:

```json
{
  "references": [
    {
      "type": "index-pattern",
      "id": "logs-*",
      "name": "kibanaSavedObjectMeta.searchSourceJSON.index"
    },
    {
      "type": "index-pattern",
      "id": "01d64a72-a702-4a41-8ba3-b87d45c40814",
      "name": "panel-uuid:indexpattern-datasource-layer-layer1"
    },
    {
      "type": "visualization",
      "id": "50643b60-3dd3-11e8-b2b9-5d5dc1715159",
      "name": "panel_5"
    }
  ]
}
```

## Panel Configuration

Panels represent individual visualizations within a dashboard. The grid system
uses a **48-column layout** where panels are positioned using `gridData`
coordinates.

### Panel Object Structure

Each panel in the `panelsJSON` array follows this structure:

```typescript
interface PanelState {
  version: string;          // Kibana version (e.g., "8.6.0")
  type: string;             // 'lens', 'visualization', 'map', 'search', 'links'
  panelIndex: string;       // UUID matching gridData.i
  panelRefName?: string;    // For by-reference: 'panel_{panelIndex}'
  title?: string;           // Custom panel title
  gridData: {
    x: number;              // 0-47 (48-column grid)
    y: number;              // 0+ (infinite rows)
    w: number;              // Width 1-48
    h: number;              // Height in row units
    i: string;              // Panel ID (must match panelIndex)
    row?: string;           // NEW in 9.x: parent section ID
  };
  embeddableConfig: {
    attributes?: object;    // By-value: full visualization state
    enhancements?: object;  // Drilldowns, actions
    hidePanelTitles?: boolean;
  };
}
```

### Grid Positioning Rules

- **x**: Horizontal position (0-47, max 48 columns total)
- **y**: Vertical position (rows from top, no maximum)
- **w**: Width in grid columns (1-48)
- **h**: Height in grid units (minimum varies by panel type)
- **i**: Unique identifier string (must match `panelIndex`)

**Common Layout Patterns**:

| Layout | Grid Configuration |
| -------- | ------------------- |
| Full width | `{"x":0,"y":0,"w":48,"h":8}` |
| Half width (left) | `{"x":0,"y":0,"w":24,"h":15}` |
| Half width (right) | `{"x":24,"y":0,"w":24,"h":15}` |
| Three columns | `w:16` at `x:0`, `x:16`, `x:32` |

### By-Reference vs By-Value Panels

This is the **most critical distinction** for compiler implementations.

#### By-Reference Panels

Link to separately saved visualization objects:

```json
{
  "type": "visualization",
  "gridData": {"x":0,"y":21,"w":24,"h":10,"i":"5"},
  "panelIndex": "5",
  "embeddableConfig": { "enhancements": {} },
  "panelRefName": "panel_5"
}
```

The `panelRefName` must match an entry in the dashboard's `references` array:

```json
{
  "type": "visualization",
  "id": "50643b60-3dd3-11e8-b2b9-5d5dc1715159",
  "name": "panel_5"
}
```

#### By-Value Panels (Recommended)

Embed the complete visualization inline:

```json
{
  "type": "lens",
  "gridData": {"x":0,"y":0,"w":24,"h":15,"i":"uuid-here"},
  "panelIndex": "uuid-here",
  "embeddableConfig": {
    "hidePanelTitles": false,
    "attributes": {
      "title": "",
      "visualizationType": "lnsXY",
      "type": "lens",
      "references": [
        {
          "type": "index-pattern",
          "id": "logs-*",
          "name": "indexpattern-datasource-layer-layer1"
        }
      ],
      "state": { /* Full Lens state */ }
    },
    "enhancements": {}
  }
}
```

**For YAML compilers targeting Lens, by-value panels are the recommended
approach** as they create self-contained dashboards that are easier to version
control and deploy.

### Panel Type Compatibility

| Panel Type | `type` Value | 8.x | 9.x | Recommended |
| ----------- | -------------- | ----- | ----- | ------------- |
| Lens | `lens` | ✓ | ✓ | **Yes** |
| Legacy Viz | `visualization` | ✓ | Existing only | No |
| TSVB | `visualization` | ✓ | Existing only | No |
| Maps | `map` | ✓ | ✓ | Yes |
| Saved Search | `search` | ✓ | ✓ | Yes |
| Links | `links` | ✓ | ✓ | Yes |
| Collapsible Section | `section` | — | ✓ | Yes (9.x+) |
| Vega | `visualization` | ✓ | ✓ | Yes |

### Collapsible Sections (8.19+, 9.x)

Collapsible sections allow panels to be grouped into expandable/collapsible
rows:

```json
{
  "rows": {
    "section-1": {
      "id": "section-1",
      "title": "Section Title",
      "collapsed": false,
      "panels": {
        "panel-1": { "type": "lens", "gridData": {...} }
      }
    }
  },
  "panels": {
    "ungrouped-panel": { "type": "lens", "gridData": {...} }
  }
}
```

Key implications:

- Collapsed sections **lazy-load content**, improving performance
- The `gridData.row` property links panels to their parent section
- Uses custom CSS grid layout engine (`kbn-grid-layout`) replacing
  `react-grid-layout`

## Lens Visualization Architecture

Lens is Kibana's modern visualization editor and the primary target for new
dashboards. Its state object is complex but follows a consistent schema.

### Lens Attributes Structure

```json
{
  "title": "My Chart",
  "visualizationType": "lnsXY",
  "type": "lens",
  "references": [
    {
      "type": "index-pattern",
      "id": "01d64a72-a702-4a41-8ba3-b87d45c40814",
      "name": "indexpattern-datasource-layer-layer1"
    }
  ],
  "state": {
    "datasourceStates": {
      "formBased": {
        "layers": {
          "layer1": {
            "columns": { /* Column definitions */ },
            "columnOrder": ["col1", "col2"],
            "indexPatternId": "01d64a72-a702-4a41-8ba3-b87d45c40814"
          }
        }
      }
    },
    "visualization": { /* Visualization-specific config */ },
    "query": {"query": "", "language": "kuery"},
    "filters": []
  }
}
```

### Lens Visualization Types

| visualizationType | Description | Common Use Cases |
| ------------------- | ------------- | ------------------ |
| `lnsXY` | Line, area, bar charts | Time series, comparisons |
| `lnsPie` | Pie and donut charts | Proportions, distributions |
| `lnsMetric` | Single metric display | KPIs, counts |
| `lnsDatatable` | Data tables | Raw data, breakdowns |
| `lnsGauge` | Gauge visualizations | Progress, thresholds |
| `lnsHeatmap` | Heatmaps | Density, correlations |
| `lnsTagcloud` | Tag clouds | Word frequency |
| `lnsMosaic` | Mosaic charts | Multi-dimensional proportions |

### Lens Column Configuration

Columns define the data transformations (metrics and buckets):

```json
{
  "col1": {
    "dataType": "date",
    "isBucketed": true,
    "label": "@timestamp",
    "operationType": "date_histogram",
    "params": {"interval": "auto"},
    "sourceField": "@timestamp"
  },
  "col2": {
    "dataType": "number",
    "isBucketed": false,
    "label": "Count",
    "operationType": "count",
    "sourceField": "Records"
  }
}
```

**Operation types include**:

- **Metrics**: `count`, `sum`, `avg`, `max`, `min`, `cardinality`, `percentile`,
  `median`, `last_value`, `unique_count`
- **Buckets**: `date_histogram`, `terms`, `filters`, `range`
- **Advanced**: Formula-based operations

### Lens XY Visualization State

For `lnsXY` charts, the visualization state specifies how columns map to visual
elements:

```json
{
  "visualization": {
    "layers": [{
      "layerId": "layer1",
      "accessors": ["col2"],
      "xAccessor": "col1",
      "seriesType": "bar"
    }],
    "preferredSeriesType": "bar",
    "legend": {"isVisible": true, "position": "right"},
    "valueLabels": "hide"
  }
}
```

**Series types**: `bar`, `line`, `area`, `bar_stacked`, `bar_horizontal`,
`bar_horizontal_stacked`, `area_stacked`.

### Lens Datasources

Kibana 9.x introduces multiple datasource types:

| Datasource | State Key | Usage |
| ------------ | ----------- | ------- |
| Form-based | `formBased` | Standard aggregation-based queries |
| Text-based | `textBased` | ES\|QL queries (9.x+) |

**Form-based datasource** (most common):

```json
{
  "formBased": {
    "layers": {
      "layer1": {
        "columns": { /* column configurations */ },
        "columnOrder": ["col1", "col2"],
        "indexPatternId": "data-view-id"
      }
    }
  }
}
```

**Text-based datasource** (ES|QL):

```json
{
  "textBased": {
    "layers": {
      "layer1": {
        "query": {
          "esql": "FROM logs* | STATS count() BY @timestamp"
        },
        "columns": [...],
        "timeField": "@timestamp"
      }
    }
  }
}
```

## Advanced Features

### ES|QL Variable Controls (9.x+)

New control types enable dynamic dashboard filtering through ES|QL queries:

| Version | Naming |
| --------- | -------- |
| 9.0-9.1 | "ES\|QL controls" |
| 9.2+ | "Variable controls" |

Variable prefixes in ES|QL queries:

- `?variableName` — value variables (filter values)
- `??variableName` — field/function variables

```json
{
  "controlGroupInput": {
    "controls": [
      {
        "id": "esql-control-1",
        "type": "esqlControl",
        "variableName": "myVariable",
        "variableType": "value",
        "options": {
          "type": "query",
          "query": "FROM logs* | STATS count() BY field | LIMIT 100"
        }
      }
    ],
    "chainingSystem": "HIERARCHICAL",
    "labelPosition": "oneLine"
  }
}
```

### Drilldown Configuration

Panel drilldowns enable interactive navigation:

```json
{
  "embeddableConfig": {
    "enhancements": {
      "dynamicActions": {
        "events": [{
          "eventId": "drilldown-1",
          "triggers": ["VALUE_CLICK_TRIGGER"],
          "action": {
            "factoryId": "DASHBOARD_TO_DASHBOARD_DRILLDOWN",
            "name": "View Details",
            "config": {
              "dashboardId": "target-dashboard-id",
              "useCurrentFilters": true,
              "useCurrentDateRange": true
            }
          }
        }]
      }
    }
  }
}
```

**Trigger types**: `VALUE_CLICK_TRIGGER`, `RANGE_SELECT_TRIGGER`,
`ROW_CLICK_TRIGGER`.

## API Reference

### Saved Objects API Endpoints

The primary API for dashboard management:

| Method | Endpoint | Purpose |
| -------- | ---------- | --------- |
| `POST` | `/api/saved_objects/_export` | Export dashboards (NDJSON) |
| `POST` | `/api/saved_objects/_import` | Import dashboards |
| `GET` | `/api/saved_objects/dashboard/{id}` | Retrieve single dashboard |
| `POST` | `/api/saved_objects/dashboard` | Create dashboard |
| `PUT` | `/api/saved_objects/dashboard/{id}` | Update dashboard |

**Space-aware endpoints** use the format: `/s/{space_id}/api/saved_objects/...`

### NDJSON Export Format

Kibana exports use Newline Delimited JSON, where each line is a complete saved
object:

```json
{"id":"index-pattern-id","type":"index-pattern","attributes":{...}}
{"id":"dashboard-id","type":"dashboard","attributes":{...},"references":[...]}
```

**Export request body**:

```json
{
  "objects": [{"id": "dashboard-id", "type": "dashboard"}],
  "includeReferencesDeep": true,
  "excludeExportDetails": false
}
```

### Internal APIs Blocked in 9.0

**Critical 9.0 change**: Internal Kibana HTTP APIs now return `400 Bad Request`
when accessed without proper internal headers. This restriction is **enabled by
default** and affects undocumented `/api/*` and `/internal/*` routes.

Compilers should use only publicly documented APIs listed above.

Required headers for all API calls:

```text
kbn-xsrf: true
Content-Type: application/json
```

### Deprecated/Removed APIs

| Removed API | Replacement |
| ------------- | ------------- |
| `GET /api/kibana/dashboards/export` | `POST /api/saved_objects/_export` |
| `POST /api/kibana/dashboards/import` | `POST /api/saved_objects/_import` |

## Complete Example: By-Value Lens Dashboard

```json
{
  "id": "my-dashboard",
  "type": "dashboard",
  "typeMigrationVersion": "8.9.0",
  "attributes": {
    "title": "Application Metrics",
    "version": 1,
    "timeRestore": true,
    "timeFrom": "now-24h",
    "timeTo": "now",
    "refreshInterval": {"pause": false, "value": 30000},
    "kibanaSavedObjectMeta": {
      "searchSourceJSON": "{\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filter\":[]}"
    },
    "optionsJSON": "{\"useMargins\":true,\"syncColors\":false,\"syncCursor\":true,\"syncTooltips\":false,\"hidePanelTitles\":false}",
    "panelsJSON": "[{\"type\":\"lens\",\"gridData\":{\"x\":0,\"y\":0,\"w\":24,\"h\":15,\"i\":\"panel1\"},\"panelIndex\":\"panel1\",\"embeddableConfig\":{\"attributes\":{\"title\":\"Request Count Over Time\",\"visualizationType\":\"lnsXY\",\"type\":\"lens\",\"references\":[{\"type\":\"index-pattern\",\"id\":\"logs-*\",\"name\":\"indexpattern-datasource-layer-layer1\"}],\"state\":{\"datasourceStates\":{\"formBased\":{\"layers\":{\"layer1\":{\"columns\":{\"col1\":{\"dataType\":\"date\",\"isBucketed\":true,\"label\":\"@timestamp\",\"operationType\":\"date_histogram\",\"params\":{\"interval\":\"auto\"},\"sourceField\":\"@timestamp\"},\"col2\":{\"dataType\":\"number\",\"isBucketed\":false,\"label\":\"Count\",\"operationType\":\"count\",\"sourceField\":\"Records\"}},\"columnOrder\":[\"col1\",\"col2\"]}}}},\"visualization\":{\"layers\":[{\"layerId\":\"layer1\",\"accessors\":[\"col2\"],\"xAccessor\":\"col1\",\"seriesType\":\"bar\"}],\"preferredSeriesType\":\"bar\",\"legend\":{\"isVisible\":true,\"position\":\"right\"}},\"query\":{\"query\":\"\",\"language\":\"kuery\"},\"filters\":[]}},\"enhancements\":{}}}]"
  },
  "references": [
    {
      "type": "index-pattern",
      "id": "logs-*",
      "name": "panel1:indexpattern-datasource-layer-layer1"
    }
  ]
}
```

## Compiler Implementation Guidelines

### Version Detection Strategy

Check `typeMigrationVersion` or response headers to determine target version:

- **8.x**: Use stringified JSON format with SavedObjects API
- **9.x**: Same stringified format works; new Dashboard API (when available)
  accepts destringified

### Output Generation for Dual Compatibility

For a YAML-to-Kibana compiler, the output generation process should:

1. **Stringify** `options` → `optionsJSON`
2. **Stringify** `panels` → `panelsJSON`
3. **Stringify** `searchSource` → `searchSourceJSON`
4. **Extract** panel references → `references` array
5. **Generate** unique UUIDs for `panelIndex` and `gridData.i` (must match)
6. **Include** `typeMigrationVersion` appropriate to target version
7. **Flatten** embedded Lens references to dashboard's top-level `references`
   array with proper naming

### Critical Implementation Details

1. **JSON Stringification**: The `panelsJSON`, `optionsJSON`, and
   `searchSourceJSON` fields must be properly escaped JSON strings within the
   final output.

2. **UUID Generation**: Each panel needs a unique identifier that appears in
   both `panelIndex` and `gridData.i`.

3. **Reference Extraction**: When generating by-value Lens panels, extract
   index pattern references from the embedded `attributes.references` and add
   them to the dashboard's top-level `references` array with the naming
   convention `{panelIndex}:indexpattern-datasource-layer-{layerId}`.

4. **Reference Naming**: Follow established naming patterns for different
   reference types (see "Reference Naming Conventions" section above).

5. **Target Lens Exclusively**: For future-proof compilation, generate only
   Lens visualizations (`lns*` types) as legacy visualization creation is
   disabled in 9.0 and scheduled for removal in 10.0.

### Future-Proofing Considerations

- **Prefer by-value panels** for self-contained, version-controllable dashboards
- **Target Lens exclusively** for long-term compatibility
- **Use formBased datasource** for standard aggregations
- **Consider textBased datasource** for ES|QL queries (9.x+)
- **Support collapsible sections** for improved organization (8.19+, 9.x)
- **Implement variable controls** for dynamic filtering (9.x+)

## Source Code References

For deeper implementation details, these Kibana repository paths contain
authoritative type definitions:

| Path | Contents |
| ------ | ---------- |
| `src/plugins/dashboard/common/types.ts` | Core dashboard TypeScript types |
| `src/plugins/dashboard/common/bwc/types.ts` | Backward compatibility types |
| `src/plugins/dashboard/common/saved_dashboard_references.ts` | Reference extraction/injection logic |
| `x-pack/platform/plugins/shared/lens/` | Lens plugin implementation |
| `src/plugins/embeddable/README.md` | Embeddable system documentation |
| `packages/core/saved-objects/` | Core saved object schemas |

## OpenAPI Specifications

Official Kibana API schemas are available at:

- **JSON**: `https://www.elastic.co/docs/api/doc/kibana.json`
- **YAML**: `https://www.elastic.co/docs/api/doc/kibana.yaml`

## Summary: Key Takeaways for AI Agents

When working with Kibana dashboard compilation:

1. **Understand the stringified JSON pattern** - Most complex data in
   `attributes` is stringified JSON
2. **Use by-value panels** - Embed full Lens configurations inline for
   self-contained dashboards
3. **Target Lens exclusively** - Legacy visualization types are deprecated and
   will be removed in Kibana 10.0
4. **Follow reference naming conventions** - Proper naming is critical for
   linking panels to data views
5. **Generate matching UUIDs** - `panelIndex` and `gridData.i` must match
6. **Respect the 48-column grid** - Use standard layout patterns for consistent
   positioning
7. **Use the Saved Objects API** - This is the primary interface for dashboard
   management
8. **Support version evolution** - Use `typeMigrationVersion` for compatibility
   tracking
9. **Consider collapsible sections** - Modern dashboards benefit from
   organizational features (8.19+, 9.x)
10. **Leverage ES|QL controls** - Variable controls enable dynamic filtering
    (9.x+)

This architecture reference provides the foundation for building robust
YAML-to-Kibana compilation tools that generate compatible, future-proof
dashboard configurations.
